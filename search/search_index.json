{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Xeta Reality Overview Quicklinks Xeta Blockchain Pools & Programs Launch Your Project on XETA About Xeta What is Xeta Reality? Xeta Reality is a project focused on enabling dApps, gaming and metaverse use-cases using blockchain, AI vision and 3D graphics. Currently Working On: Xeta Blockchain - A high-throughput, low-cost, lightweight blockchain for metaverse and gaming applications More About Xeta Blockchain General Focus Areas Xeta Reality is focused on promoting Gaming and Metaverse adoption using blockchains (think asset registry, virtualization, dApps) and vision AI (object detection/segmentation). The 6 core pillars of Xeta Reality are: 1. Scanning and virtualization of things : Simplifying asset virtualization by building 3D scanning tools/apps to empower anyone to digitize anything anywhere. Extensive research & development of object detection/segmentation AI models. 2. Interoperability between blockchains and realities : Enabling the exchange of fungible and non-fungible assets between common blockchains and parallel realities (physical reality, virtual worlds, omniverses). 3. Asset registry, tokenization and authenticity : Building a L1 blockchain to simplify asset registry and tokenization of things. Integrating identity, deduplication and IP-protection middleware, specifically for NFTs and virtual items (image, video, audio). 4. Virtual economies (DEXs, NFT marketplaces, auctions) : Creation of exchanges & marketplaces for tokens, NFTs, avatars, skins, virtual properties and virtual ad space. Provisioning \"one-click-setup\" DEXs and marketplaces using no-code interfaces. 5. dApp ecosystem (identity, staking, 3rd party) : Providing core functionality dApps (for identity, staking, etc) using Xeta Blockchain and setting up a grant-based incentive program for 3rd party developers. 6. Community, contributors & partnerships : Building and maintaining an active community of ambassadors, providing well documented software to contributors and seeking partnerships with companies for collaboration around Metaverse technologies.","title":"Xeta Reality Overview"},{"location":"#xeta-reality-overview","text":"","title":"Xeta Reality Overview"},{"location":"#quicklinks","text":"Xeta Blockchain Pools & Programs Launch Your Project on XETA About Xeta","title":"Quicklinks"},{"location":"#what-is-xeta-reality","text":"Xeta Reality is a project focused on enabling dApps, gaming and metaverse use-cases using blockchain, AI vision and 3D graphics.","title":"What is Xeta Reality?"},{"location":"#currently-working-on","text":"Xeta Blockchain - A high-throughput, low-cost, lightweight blockchain for metaverse and gaming applications More About Xeta Blockchain","title":"Currently Working On:"},{"location":"#general-focus-areas","text":"Xeta Reality is focused on promoting Gaming and Metaverse adoption using blockchains (think asset registry, virtualization, dApps) and vision AI (object detection/segmentation). The 6 core pillars of Xeta Reality are: 1. Scanning and virtualization of things : Simplifying asset virtualization by building 3D scanning tools/apps to empower anyone to digitize anything anywhere. Extensive research & development of object detection/segmentation AI models. 2. Interoperability between blockchains and realities : Enabling the exchange of fungible and non-fungible assets between common blockchains and parallel realities (physical reality, virtual worlds, omniverses). 3. Asset registry, tokenization and authenticity : Building a L1 blockchain to simplify asset registry and tokenization of things. Integrating identity, deduplication and IP-protection middleware, specifically for NFTs and virtual items (image, video, audio). 4. Virtual economies (DEXs, NFT marketplaces, auctions) : Creation of exchanges & marketplaces for tokens, NFTs, avatars, skins, virtual properties and virtual ad space. Provisioning \"one-click-setup\" DEXs and marketplaces using no-code interfaces. 5. dApp ecosystem (identity, staking, 3rd party) : Providing core functionality dApps (for identity, staking, etc) using Xeta Blockchain and setting up a grant-based incentive program for 3rd party developers. 6. Community, contributors & partnerships : Building and maintaining an active community of ambassadors, providing well documented software to contributors and seeking partnerships with companies for collaboration around Metaverse technologies.","title":"General Focus Areas"},{"location":"handbook/","text":"Xeta Reality Handbook Documentation for Modules and Programs Version 0.8.1 23rd December, 2021 https://xetareality.com https://xeta.network \\pagebreak","title":"Handbook"},{"location":"handbook/#xeta-reality-handbook","text":"","title":"Xeta Reality Handbook"},{"location":"handbook/#documentation-for-modules-and-programs","text":"Version 0.8.1 23rd December, 2021 https://xetareality.com https://xeta.network \\pagebreak","title":"Documentation for Modules and Programs"},{"location":"pools-programs/","text":"Pools & Programs Xeta focuses on gaming and metaverse applications that commonly require features such as auctions, voting, swapping. With Xeta Core, we provide these 9 in-built programs, which can be specified as program when creating a new pool: Auctions Auctions allow anyone to offer fungible or non-fungible tokens for sale. Bids are handled by the program and auctions are considered successful when the auction pool has no target, the target is met, or the limit is met (which is equivalent to an instant purchase at maximum price) Fee Delegation Fee delegation pools are holding XETA tokens which can be used for transaction fee reimbursements, when users are transacting with that specific asset (think: fee-less voting, fee-less trading, fee-less participation in airdrops). The intention behind fee delegation is to avoid passing off costs to end users (which is not always wanted). Fund Raising Fundraising pools allow creators to raise XETA until a certain target or limit is met. Successful funds distribute portions of the raised amount to the creator, and the remainder to the assets own swap-pool as liquidity. If a rate is set, the fund automatically swaps XETA to asset tokens at the specified rate directly, without the delay or condition of having to meet a fundraising goal. Loot Loot pools allow NFT creators and games (think skins) to distribute (drop) new items from the collection in a randomized and engaging way. Users can enter (for free or for a fee as specified by the pool creator) and receive tickets which have a certain probability to win a random item from the loot pool. Locking Locking pools allow asset creators to lock funds for various use-cases, such as delayed payouts and vesting. Lottery Promo pools provide an airdrop/lottery mechanism, which can be used to engage users or to distribute tokens in a simple and fair way. Staking Staking pools allow token creators to provide a reward for holders, depending on lock-up length and amount. For example, a pool creator might specify a certain APY for his pool, provide reward tokens, and allow users to lock-up tokens into the pool who then will receive rewards once their lock-up period expires. Swapping Swapping pools are pools holding XETA and the pool-asset, which can then be swapped. Swap pools are classical DEXes, like Uniswap or Pancakeswap. Voting Voting pools allow users to submit votes given a list of assets/addresses, or numbers (prediction markets). Voting can be used for governance (voting for new proposals), for predictions with payouts to the winning voters, or as way to engage users (mechanism to vote on any tokenized object, and get paid if the vote was correct after resolution).","title":"Pools & Programs"},{"location":"pools-programs/#pools-programs","text":"Xeta focuses on gaming and metaverse applications that commonly require features such as auctions, voting, swapping. With Xeta Core, we provide these 9 in-built programs, which can be specified as program when creating a new pool:","title":"Pools &amp; Programs"},{"location":"pools-programs/#auctions","text":"Auctions allow anyone to offer fungible or non-fungible tokens for sale. Bids are handled by the program and auctions are considered successful when the auction pool has no target, the target is met, or the limit is met (which is equivalent to an instant purchase at maximum price)","title":"Auctions"},{"location":"pools-programs/#fee-delegation","text":"Fee delegation pools are holding XETA tokens which can be used for transaction fee reimbursements, when users are transacting with that specific asset (think: fee-less voting, fee-less trading, fee-less participation in airdrops). The intention behind fee delegation is to avoid passing off costs to end users (which is not always wanted).","title":"Fee Delegation"},{"location":"pools-programs/#fund-raising","text":"Fundraising pools allow creators to raise XETA until a certain target or limit is met. Successful funds distribute portions of the raised amount to the creator, and the remainder to the assets own swap-pool as liquidity. If a rate is set, the fund automatically swaps XETA to asset tokens at the specified rate directly, without the delay or condition of having to meet a fundraising goal.","title":"Fund Raising"},{"location":"pools-programs/#loot","text":"Loot pools allow NFT creators and games (think skins) to distribute (drop) new items from the collection in a randomized and engaging way. Users can enter (for free or for a fee as specified by the pool creator) and receive tickets which have a certain probability to win a random item from the loot pool.","title":"Loot"},{"location":"pools-programs/#locking","text":"Locking pools allow asset creators to lock funds for various use-cases, such as delayed payouts and vesting.","title":"Locking"},{"location":"pools-programs/#lottery","text":"Promo pools provide an airdrop/lottery mechanism, which can be used to engage users or to distribute tokens in a simple and fair way.","title":"Lottery"},{"location":"pools-programs/#staking","text":"Staking pools allow token creators to provide a reward for holders, depending on lock-up length and amount. For example, a pool creator might specify a certain APY for his pool, provide reward tokens, and allow users to lock-up tokens into the pool who then will receive rewards once their lock-up period expires.","title":"Staking"},{"location":"pools-programs/#swapping","text":"Swapping pools are pools holding XETA and the pool-asset, which can then be swapped. Swap pools are classical DEXes, like Uniswap or Pancakeswap.","title":"Swapping"},{"location":"pools-programs/#voting","text":"Voting pools allow users to submit votes given a list of assets/addresses, or numbers (prediction markets). Voting can be used for governance (voting for new proposals), for predictions with payouts to the winning voters, or as way to engage users (mechanism to vote on any tokenized object, and get paid if the vote was correct after resolution).","title":"Voting"},{"location":"whitepaper/","text":"Xeta Whitepaper September 2021 Version 0.8 A Serverless Blockchain for Metaverse, Gaming, and NFT applications Xeta is a serverless layer-1 blockchain that provides infinite scalability, high throughput, sub-second confirmation times, and fees at a tenth of a cent. Xeta achieves this by leveraging serverless compute and storage cloud services while innovating incentive structures and extending the Byzantine Fault Tolerance consensus mechanism for scalability. Introduction We have witnessed a rapid increase in Metaverse, Gaming, and NFT adoption during the recent year. The increased demand brought infrastructural challenges, considering these applications' throughput, fee, and latency requirements. Current solutions such as Bitcoin, Ethereum, and more recently, Binance Smart Chain have shown to be not viable enough as long-term candidates for these rapidly expanding industries: the transaction confirmation times are too slow, and the fees are too high. These issues originate from the inherently nonoptimal economic incentives layer, which is the most challenging part of adjusting once implemented. Misalignments in incentives are precisely why Bitcoin, Ethereum, or BSC nodes are not willing to charge lower fees or process transactions faster. Xeta is a lightweight and serverless solution that solves the incentive problems by incentivizing validators to compete for speed and fees. Xeta builds on top of available serverless infrastructure services offered by all major cloud providers, leveraging the simplicity, predictability, and (theoretically) infinite scalability of storage and compute. Rather than spending significant portions of time, focus, and development resources on innovating distributed compute and storage, Xeta wants to build upon proven serverless offerings from major cloud providers and decide to focus on what matters most to Xeta's mission: the advancement of Metaverse, Gaming and NFT adoption at the interface level, with the goal to onboard 100 million users. To do that, Xeta provides a lightweight but highly scalable blockchain with native pre-written and extensively tested \"programs\" that asset-pools can use. These programs currently include ten common decentralized finance and gaming functionalities such as auctions, fee delegation, launch pads/fundraising, locking/vesting, loot boxes/drop zones, lottery/airdrops, royalty/assets with native yield, staking, swapping/decentralized trading, and voting. Serverless Architecture We propose a new serverless blockchain architecture that focuses on user benefits such as fast transaction confirmation times, low fees (around $0.001), and theoretically infinite data scalability for the demands of Gaming, Metaverse, and Web 3.0 applications (easily in the TB/PB range) by leveraging serverless cloud services. Xeta's node software can be executed on any machine in theory. However, we see an enormous opportunity in serverless offerings by major cloud providers, which allows tapping into proven, stable, and theoretically infinitely scalable compute and storage services while providing the most demanded benefits to end-users (fast confirmation times, low fees, and integrity/verifiability of transactions). Serverless technologies by common cloud platforms such as AWS, Azure, GCP, Alibaba Cloud were early in 2019/2020. Today, however, we can label these as fully mature and production-grade choices. Furthermore, many content delivery networks such as Cloudflare and Fastly also provide edge-compute capabilities, which have improved to the point of supporting the demands of high-throughput financial transfers. The level of maturity, the ease of access/setup, and linear cost models are reasons for Xeta to focus exclusively on the serverless stack through offerings by the cloud platforms mentioned above. For compute functionality, this encompasses building on AWS Lambda, Azure Functions, Google Cloud Functions, Alibaba Function Compute, Cloudflare Workers, and Fastly Compute@Edge. Storage leverages Amazon Quantum Ledger DB, Amazon DynamoDB, Azure CosmosDB, Google Firestore, Alibaba Tablestore, and Cloudflare Workers KV. Xeta aims to eventually allow anyone to run confirmation nodes in just two steps, 1. by providing programmatic API keys from either of these platforms and 2. to subscribe to the transactions mempool (a high throughput topic service responsible for ordering and broadcasting transactions). Hence, we hope to democratize opportunities to run nodes, to provide work for the Xeta network while getting compensated in a way that makes sense economically for individual entities. Scalability Serverless infrastructure can scale depending on the limits of underlying technologies as offered by cloud providers. In Xeta's case, we reached a peak of 80k TPS with our current setup. The storage and compute capabilities are theoretically limitless (practically, limited to node providers' account limits or global limits enforced by cloud providers due to hardware constraints). Most serverless compute offerings can support hundreds of thousands of invocations per second, while storage offerings can store trillions of records at a petabyte-scale. To participate in the validation of transactions on Xeta, one only requires to know about the last confirmed transaction affecting the form/to balance, which means that the minimum requirement for joining as a node is extremely low (there is no need to store the entire ledger nor to keep the state of all balances). Xeta Benefits Sub-second confirmation times for transactions Minimal fees (approx. $0.001 per transaction for simple transfers) Infinite scalability and storage (with linear cost) An adjusted Byzantine Fault Tolerance consensus mechanism Proof of Audit mechanism for integrity and verifiability of transactions Fee delegation (owners can choose to pay for fees for users' transactions) Pools & programs tailored and optimized for Gaming/Metaverse/Web 3.0 use-cases Native read-only interfaces (APIs, frontends) for clients Permissionless Validation Proof of Audit \"It is possible to verify payments without running a full network node.\" Xeta allows any client/node to validate transactions and balances (states) at any given time. With each transaction, Xeta nodes broadcast the resulting state (new to and from balances), representing their vote about the outcome. The updated state offers clients a running balance which provides an easy way to audit transaction histories without knowing about all prior transactions or global balance states. If clients don't trust publishing nodes with transactions (or need to perform audits for their own reasons), they can openly confirm balances as many steps back as they require based on their desired confidence level. The simplest audit that a client can perform is requesting the two prior transactions affecting from/to addresses of the transaction to be verified. Clients can confirm that a certain \"UTXO\" existed and was correctly reflected by the new transaction. This functionality can be performed through a public API and interface provided by Xeta read-only nodes so that anyone can participate and make use of this validation methodology when desired. Blockless Ledger Xeta nodes validate and process every transaction individually, rather than agreeing on the validity of a group of transactions within a block. In practice, this means Xeta is blockless or that every transaction can be treated as a block of one. This allows Xeta to produce a continuous data structure of transactions (public ledger) and states (public balances). The benefit for applications is the easy access of transaction history and state of balances at any given point in time while being able to verify the integrity of each transaction (proof of audit). Xeta Consensus Xeta Byzantine Fault Tolerance Xeta builds on top of the original BFT mechanism proposed by Lamport, Shostak, and Pease and the Practical Byzantine Fault Tolerance (PBFT) approach proposed by Castro and Liskov. We propose a modified mechanism following four progressive rounds for every transaction: proposal, voting, quorum, synchronization. 1. Proposal Any node automatically becomes a leader if it submits the first confirmation for a transaction (resulting balances and reflected state). N Nodes propose their solution to the coordinator client, which registers the first confirming node as leader/authority for the transaction to be confirmed. 2. Voting All subsequent votes (within the acceptable voting window of 1500ms after the transaction has been broadcasted) confirm the leader's vote or object in case their proposed state differs from the leaders' solution. Once confirmations of all participating nodes arrive or the window of 1500ms expires, the voting is considered complete. 3.1 Quorum (total agreement) Usually, transactions are confirmed without conflicts, meaning all nodes confirm the same states as the leader node. In this case, the transaction fee is distributed to all participating nodes. The leader receives at least 10%, while all other nodes share the fee reminder proportionally. 3.2 Quorum (partial agreement) A transaction is also considered confirmed if the weight of confirmations vs. objections is at least 4/5. The weight of each vote is a function of the staked amount by voting nodes multiplied by a factor for length of operation. The node(s) who objected (with <1/5 weight) are deducted a penalty of 0.1-Objection Weight/500 of their staked amount, which is distributed at synchronization step among the then-majority. 3.3 Quorum (non-agreement) If a vote does not reach 4/5 voting weight, it is considered unconfirmed and is rebroadcasted by the coordinator node so that all nodes can resubmit their votes. The same penalty of 0.1-Objection Weight/500 is applied on every round of rebroadcasting to all nodes who object until an agreement (4/5 majority) is reached. Voting nodes can decide to change their initial vote or drop out (by themselves or when staking requirements fall below minimum). 4. Synchronization After a transaction has been confirmed, it is pushed to all nodes, which might update their ledgers based on the outcome (if they have not voted correctly already, or if they are nodes interested in the partition range of the transaction). If a transaction has amassed a penalty balance (due to objecting nodes), it is distributed to the majority (which could flip during voting/rebroadcasting, so penalties are not distributed at every voting round but only after final confirmation). Validator Staking Requirements Nodes who want to participate in the confirmation of transactions have to stake at least 1,000,000 XETA. Our current fee structure allows approximately 50 nodes to participate economically while financing the underlying infrastructure and making a profit. Xeta BFT Conclusion Xeta BFT incentivizes high throughput, low latency, and energy efficiency (unlike PoW mechanisms). Additionally, it guarantees the finality of transactions after the self-imposed maximum confirmation window of 1500ms closes. Lastly, this mechanism ensures that the network functions under a certain amount of faulty nodes (whether unintentionally by being out of sync with the current state or by their intention to harm the network). Mempool & Nodes Xeta Mempool Double spending is the biggest problem for distributed networks like Bitcoin or Ethereum. A \"double spend\" occurs when transactions arrive in different orders on different nodes. Think about a transaction, sending 10 XETA from wallet A to B, and another transaction sending 10 XETA from wallet A to C. Assuming wallet A has only 10 XETA, one of these two transactions must fail by default. However, hypothetically, if both transactions are submitted to different nodes in different orders, a double spend occurs (assuming nodes don't coordinate between each other - which is precisely what consensus mechanisms are designed to do). The Xeta Mempool is a global pub/sub system for all incoming transactions and is responsible for broadcasting these transactions to all subscribing pools. It provides an agreed-upon ordering for messages, which solves the double-spending problem. Additionally, the Xeta Mempool involves multiple fallback mechanisms to avoid a single point of failure. The current limitations of our implementation are 80k TPS and that no prioritization of transactions is possible. Additionally, transactions cannot be reshuffled or moved ahead by paying a higher fee. These attributes are intentionally waived in favor of efficient one-way sorting with higher throughput. TLDR : The Xeta Mempool is a high throughput pub/sub mechanism that ensures the sorting of transactions by order of arrival and broadcasts them to subscribing nodes that process transactions, vote on transaction outcomes, synchronize their state-ledgers, and submit confirmations. Mempool Subscribers The Xeta Mempool receives all incoming transactions and broadcasts them to subscribing nodes. Nodes can listen selectively based on their requirements and preferences (e.g., nodes might want to listen only to transactions with from-address ranges 1-9a-z and to-address ranges from A-Z). This is a purely illustrative example based on the base58 encoding range of addresses. Nodes subscribe to the Mempool, which broadcasts all incoming transactions sequentially ordered by received-at-timestamp. Messages trigger serverless compute functions, which execute modules and programs (either simple transfer, or pre-programmed functions like auctions, staking, swapping, voting, etc.) and update states of balances. Once nodes complete the computation and state reflection internally, they broadcast the result to the coordinator node and are rewarded a portion of the transaction fee upon success. Node Synchronization Nodes subscribe to the Xeta Mempool to receive incoming transactions and update them locally. Depending on different node types (read-only API node or confirmation node), nodes can participate in receiving all transactions or listen selectively and filter for specific segments. Nodes keep a local ledger and submit confirmations to balance updates they believe are correct (to participate in the transaction fee payout). Additionally, nodes consume confirmed transactions, which allows them to update the resulting to & from states locally without having kept a prior ledger. Nodes keep track of transactions internally via an incrementing number, allowing them to stay in sync and detect missed transactions. In the case of discrepancies between a local index and the one of a last broadcasted transaction, nodes can resync and replay transactions they have missed. TLDR: Xeta provides a single data structure of all records, including all states over time. This allows nodes to sync and validate the integrity of transactions at any point in time without knowledge about prior transactions or the state of balances. Node Types Xeta has four node types: coordinator nodes, validator nodes, storage nodes, audit nodes. Coordinator nodes are mediators over the voting process, which receive votes from validator nodes and submit confirmations/rebroadcast transactions, dependent on different quorum outcomes. Every validator node can become a coordinator node if agreed upon by 4/5th of the majority. Validator nodes subscribe to transactions and store a subset of transactions (depending on their preferences or limitations, e.g., different infrastructure limits imposed by certain cloud providers). Validator nodes then execute the transaction instructions and programs, reflect state locally, and submit the reflected state as their vote. The reward for validator nodes is either 0.9/(N-1)*fee if they confirm the authority/leader node or 10% if they are the first submitting node. Storage nodes subscribe to all transactions and store them on serverless storage offerings for hypothetically infinite scalability. Storage nodes provide clients with the ability to access historical balances/transactions. Audit nodes perform audits of transactions and balances by requesting historical data from storage nodes and confirming balances. Audits can be performed as many transactions back as necessary and required by applications (up to the genesis transaction of each asset). Clients can perform audits in their browsers by requesting the required data from storage nodes. Risks & Attack Vectors 51% Attack Attackers are guaranteed to be penalized a portion of their stake with every false vote they submit as confirmation. Confirming nodes have a staked amount (minimum 1,000,000 XETA) which is weighted by their length of operation. The network is secure as long as honest nodes control the majority of the total voting stake. Sybil Attack Voting weight is calculated based on the staked amount and adjusted by a factor for the length of operation. The length of operation serves as a form of reputation which is impossible to fake. Xeta accounts for vote weight rather than vote counts. Hence, the number of nodes and whether owned by the same entity or different entities do not matter. Spam Attack Attackers could spam the network with valid or invalid transactions, affecting bandwidth (best case) or bandwidth and compute resources of nodes. The Xeta Mempool runs sophisticated load balancing and protection software to ensure maximal throughput of honest transactions while throttling bad actors (or clients sending transactions with false markup leading to frequent invalid transactions). Free-Riding Transaction states are broadcasted only after the confirmation is closed and finalized. Therefore nodes can not rebroadcast existing confirmations to collect fees without providing work. Economics Fee Incentives All confirming nodes receive portions of the transaction fee for every successfully confirmed transaction. The leader (proposer of a transaction) is rewarded 10%, and all other nodes are rewarded 0.9/(N-1). A certain number N exists, which is the number of nodes at which the current static transaction fees provide economic reasons to operate a node. This number is approximately 50. Hence up to 50 nodes could participate economically in the voting process of each transaction. The authority/leader node (first node to confirm a transaction and propose the resulting state) receives at least 10% or 0.9/(N-1)*fee, whichever is larger. This simple but effective fee structure allows incentivization that is meaningful to the user by fostering competition between nodes (speed of confirmation, the truthfulness of confirmations). The proposed reward mechanism solves the collective action problems of currently popular networks, mainly the free-rider problem, which originates from misaligned incentives between nodes and clients. Ethereum incentivization discourages providing infrastructure, hence such a dependence on the heavily subsidized and non-economic Infura. Bitcoin discourages confirmation speed and low fees since volunteers are paying for the network infrastructure. TLDR: Xeta's fee structure incentivizes nodes to behave truthfully while contributing efficient infrastructure to the network. This solves collective action problems as experienced by Bitcoin and Ethereum. Pools & Programs Programs replacing EVM Xeta prioritizes client benefits (most notably confirmation speed and low fees) rather than providing a virtualized compute platform that executes bytecode. Xeta covers major use-case programs such as locking, staking, trading, voting, etc., which find importance in applications for Metaverse, Gaming, and NFTs. Focusing on a few programs rather than providing full EVM capabilities results in faster development and easier testing. Xeta provides a limited number of pre-written programs to creators who are building on top of Xeta. Creators often are not familiar with languages like Solidity and would rather spend time implementing features than writing and testing the underlying smart contracts. Lastly, each of Xeta's pre-written programs goes through extensive testing and becomes more trustworthy with every transaction processed. This is the opposite of Ethereum/BSC, where every smart contract has to be audited with each new deployment due to the possibility of change or error. TLDR: Xeta provides native programs instead of EVM functionality to improve development speed, guarantee ease of access to creators/users, and ultimately, focus on what matters most to Xeta's mission: the adoption of Metaverse/Gaming/NFT applications. Programs Xeta focuses on Gaming and Metaverse applications that frequently require features such as auctions, voting, swapping, and similar. Xeta provides ten in-built programs available as the underlying mechanism when creating a new asset pool. Asset pools are smart contracts that send and receive transactions while executing a set of pre-written instructions tied to an underlying asset. Auctions Auctions allow anyone to offer fungible or non-fungible tokens for sale. Bids are handled by the program, and auctions are considered successful when the auction pool has no target, the target is met, or the limit is met (equivalent to an instant purchase at maximum price). Fee Delegation Fee delegation pools hold XETA tokens which can be used for transaction fee reimbursements for users transacting with that specific asset (think fee-less voting, fee-less trading, fee-less participation in airdrops). The intention behind fee delegation is to avoid passing off costs to end-users (which is not always desired). Fund Raising Fundraising pools allow creators to raise XETA until a specific target or limit is met. Successful funds distribute portions of the raised amount to the creator and the remainder to the assets' swap pool as liquidity. If a pool rate is set, the fund automatically swaps XETA to asset tokens at that specified rate directly, without the condition of having to meet a fundraising goal. Loot Loot pools allow NFT creators and games to distribute (drop) new NFTs, items, skins from a collection in a randomized and engaging way. Users can enter for free or for a fee as specified by the pool creator. Entrants receive tickets that have a certain probability of winning a random item from the loot pool. Locking Locking pools allow asset owners to lock funds for various use-cases, such as delayed payouts and vesting. Lottery Promo pools provide an airdrop/lottery mechanism, which can engage users or distribute tokens in a simple and fair way. Users can participate for free or for a fee (specified upon pool creation) and receive tickets with a certain probability to win from the prize pool. Royalty Royalty pools are set up by an asset creator who wishes to reward all or parts of his assets based on a specified daily rate. Currently, this finds application in providing NFTs with yield for holding (royalties). Staking Staking pools allow token creators to reward holders of fungible tokens, depending on lock-up length and amount. For example, a pool creator might specify a certain APY and bonus rate for his pool, deposit reward tokens, and allow users to lock up tokens into the pool who will receive rewards once their lock-up period expires. Swapping Swapping pools are pools holding XETA and the pool asset, which can be exchanged one for another. Swap pools are the same functionality that makes popular DEXs like Uniswap or PancakeSwap possible. Voting Voting pools allow users to submit votes given a list of assets/addresses or numbers (prediction markets). Voting can be used for governance (voting for new proposals), for predictions with payouts to the winning voters, or to engage users (a mechanism to vote on any tokenized objects and get paid if the vote was correct after pool expiry). Xeta Reality What is Xeta Reality Xeta Reality is the overarching ecosystem consisting of Xeta (the blockchain) and various apps (mobile app for virtualization and tokenization of people and objects) and dApps (such as NFT marketplaces, DEXs, authenticity, and deduplication for NFTs). Mission Xeta's mission is to onboard 100 million users to the Metaverse by developing intuitive applications & interfaces for mainstream adoption. Focus Areas Xeta Reality focuses on promoting Metaverse, Gaming, and NFT adoption using blockchain (asset registry, virtualization, dApps) and vision AI (object detection/segmentation). The six core pillars of Xeta Reality are: Scanning and virtualizing things: Simplifying asset virtualization by building 3D scanning tools and apps to empower anyone to digitize anything anywhere. Extensive research & development of object detection and segmentation AI models. Interoperability between blockchains and realities: Enabling the exchange of fungible and non-fungible assets between common blockchains and parallel realities (physical reality, virtual worlds, omniverses). Asset registry, tokenization, and authenticity: Building a Layer-1 blockchain to simplify asset registry and tokenization of things and integrating identity, deduplication, and IP-protection middleware, specifically for NFTs and virtual items (image, video, audio). Virtual economies (DEXs, NFT marketplaces, auctions): Creation of exchanges & marketplaces for tokens, NFTs, avatars, skins, virtual properties, and virtual ad space. Provisioning \"one-click-setup\" DEXs and marketplaces using no-code interfaces. dApp ecosystem (identity, staking, 3rd party): Providing core functionality dApps (for identity, staking, etc.) using Xeta Blockchain and setting up a grant-based incentive program for 3rd party developers. Community, contributors & partnerships: Building and maintaining an active community of ambassadors, providing well-documented software to creators, and seeking partnerships with companies for collaboration and innovation around Metaverse technologies. Tokenomics Currently, there are 1 billion XETA tokens in circulation. The total circulation will be 10 billion XETA tokens. The total token circulation of 10 billion XETA tokens will be reached approximately by 2027. 1-1.5 billion XETA tokens will be in circulation on Ethereum and Binance Smart Chain (BSC), while 8.5-9B will be in circulation on the Xeta native blockchain. Bridges will make it possible to swap between these blockchains seamlessly. Allocations: 20% ecosystem & partnerships, 20% community enrichment, 15% foundation, 10% legal, marketing & biz dev, 10% future financing rounds & OTC, 10% team & development, 10% public liquidity, 5% advisors & contributors. Roadmap & Milestones Xeta Blockchain Q4 2021 - A lightweight modular blockchain to support asset tokenization and transactions with sub-second latencies. Block Explorer, Wallet & Metrics Q4 2021 - A block explorer, a wallet web app (mobile app shortly after), and an analytics dashboard for interacting with the Xeta Blockchain. Minting & Tokenization Interface Q1 2022 - Simplification of minting NFTs & creating tokens - enabled by a no-code interface. Staking dApp for Holders Q1 2022 - Launching the first Xeta Blockchain native dApp - a staking app rewarding holders by locking tokens for a predictable APY. 3D Scan Virtualization Q1 2022 - A mobile app that enables virtualization of anything with possibilities such as NFT/avatar creation or registry/virtualization of surroundings. Creation of DEXs/Marketplaces Q2 2022 - One-click creation of customizable DEXs (for tokens) and marketplaces (for NFT assets). Real-Time Object Segmentation Q2 2022 - Training vision AI models (on top of the current state-of-the-art models), capable of detecting and segmenting 200-300 different objects (integrated with the Xeta 3D scanning app). NFT Uniqueness & IP Protection Q2 2022 - Using methods such as Local Sensitive Hashing for deduplication/IP protection and governance mechanisms for conflict resolution. Digital Real Estate Q3 2022 - Bringing together Xeta Blockchain (land registry), 3D graphics, and our underlying APIs (storage) to virtualize and trade virtual land. dApp/Metaverse Ecosystem Q3 2022 - Expanding business development to establish partnerships and to implement Xeta Blockchain & Xeta Metaverse technology. Bridges & Interoperability Q4 2022 - Building bridges to transfer assets and tokens between various blockchains & virtual realities and allowing the import of assets from blockchains to Xeta/export from Xeta to other blockchains. Decentralized Data APIs Q4 2022 - Providing simple and well-documented APIs to developers for decentralized data storage and access. Join Xeta Follow us and join our community, or start building on Xeta! https://xetareality.com https://xeta.network https://t.me/XetaReality https://twitter.com/XetaReality https://www.reddit.com/r/XetaReality https://xetareality.medium.com https://github.com/XetaReality Resources https://www.theblockresearch.com/the-burden-of-infura-6899 https://bitcoin.org/bitcoin.pdf https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals-Problem.pdf https://arxiv.org/pdf/1803.05069.pdf http://pmg.csail.mit.edu/papers/osdi99.pdf https://vldb2020.org/assets/files/tutorial1_part2_system.pdf https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf","title":"Xeta Whitepaper"},{"location":"whitepaper/#xeta-whitepaper","text":"September 2021 Version 0.8 A Serverless Blockchain for Metaverse, Gaming, and NFT applications Xeta is a serverless layer-1 blockchain that provides infinite scalability, high throughput, sub-second confirmation times, and fees at a tenth of a cent. Xeta achieves this by leveraging serverless compute and storage cloud services while innovating incentive structures and extending the Byzantine Fault Tolerance consensus mechanism for scalability. Introduction We have witnessed a rapid increase in Metaverse, Gaming, and NFT adoption during the recent year. The increased demand brought infrastructural challenges, considering these applications' throughput, fee, and latency requirements. Current solutions such as Bitcoin, Ethereum, and more recently, Binance Smart Chain have shown to be not viable enough as long-term candidates for these rapidly expanding industries: the transaction confirmation times are too slow, and the fees are too high. These issues originate from the inherently nonoptimal economic incentives layer, which is the most challenging part of adjusting once implemented. Misalignments in incentives are precisely why Bitcoin, Ethereum, or BSC nodes are not willing to charge lower fees or process transactions faster. Xeta is a lightweight and serverless solution that solves the incentive problems by incentivizing validators to compete for speed and fees. Xeta builds on top of available serverless infrastructure services offered by all major cloud providers, leveraging the simplicity, predictability, and (theoretically) infinite scalability of storage and compute. Rather than spending significant portions of time, focus, and development resources on innovating distributed compute and storage, Xeta wants to build upon proven serverless offerings from major cloud providers and decide to focus on what matters most to Xeta's mission: the advancement of Metaverse, Gaming and NFT adoption at the interface level, with the goal to onboard 100 million users. To do that, Xeta provides a lightweight but highly scalable blockchain with native pre-written and extensively tested \"programs\" that asset-pools can use. These programs currently include ten common decentralized finance and gaming functionalities such as auctions, fee delegation, launch pads/fundraising, locking/vesting, loot boxes/drop zones, lottery/airdrops, royalty/assets with native yield, staking, swapping/decentralized trading, and voting. Serverless Architecture We propose a new serverless blockchain architecture that focuses on user benefits such as fast transaction confirmation times, low fees (around $0.001), and theoretically infinite data scalability for the demands of Gaming, Metaverse, and Web 3.0 applications (easily in the TB/PB range) by leveraging serverless cloud services. Xeta's node software can be executed on any machine in theory. However, we see an enormous opportunity in serverless offerings by major cloud providers, which allows tapping into proven, stable, and theoretically infinitely scalable compute and storage services while providing the most demanded benefits to end-users (fast confirmation times, low fees, and integrity/verifiability of transactions). Serverless technologies by common cloud platforms such as AWS, Azure, GCP, Alibaba Cloud were early in 2019/2020. Today, however, we can label these as fully mature and production-grade choices. Furthermore, many content delivery networks such as Cloudflare and Fastly also provide edge-compute capabilities, which have improved to the point of supporting the demands of high-throughput financial transfers. The level of maturity, the ease of access/setup, and linear cost models are reasons for Xeta to focus exclusively on the serverless stack through offerings by the cloud platforms mentioned above. For compute functionality, this encompasses building on AWS Lambda, Azure Functions, Google Cloud Functions, Alibaba Function Compute, Cloudflare Workers, and Fastly Compute@Edge. Storage leverages Amazon Quantum Ledger DB, Amazon DynamoDB, Azure CosmosDB, Google Firestore, Alibaba Tablestore, and Cloudflare Workers KV. Xeta aims to eventually allow anyone to run confirmation nodes in just two steps, 1. by providing programmatic API keys from either of these platforms and 2. to subscribe to the transactions mempool (a high throughput topic service responsible for ordering and broadcasting transactions). Hence, we hope to democratize opportunities to run nodes, to provide work for the Xeta network while getting compensated in a way that makes sense economically for individual entities. Scalability Serverless infrastructure can scale depending on the limits of underlying technologies as offered by cloud providers. In Xeta's case, we reached a peak of 80k TPS with our current setup. The storage and compute capabilities are theoretically limitless (practically, limited to node providers' account limits or global limits enforced by cloud providers due to hardware constraints). Most serverless compute offerings can support hundreds of thousands of invocations per second, while storage offerings can store trillions of records at a petabyte-scale. To participate in the validation of transactions on Xeta, one only requires to know about the last confirmed transaction affecting the form/to balance, which means that the minimum requirement for joining as a node is extremely low (there is no need to store the entire ledger nor to keep the state of all balances). Xeta Benefits Sub-second confirmation times for transactions Minimal fees (approx. $0.001 per transaction for simple transfers) Infinite scalability and storage (with linear cost) An adjusted Byzantine Fault Tolerance consensus mechanism Proof of Audit mechanism for integrity and verifiability of transactions Fee delegation (owners can choose to pay for fees for users' transactions) Pools & programs tailored and optimized for Gaming/Metaverse/Web 3.0 use-cases Native read-only interfaces (APIs, frontends) for clients","title":"Xeta Whitepaper"},{"location":"whitepaper/#permissionless-validation","text":"Proof of Audit \"It is possible to verify payments without running a full network node.\" Xeta allows any client/node to validate transactions and balances (states) at any given time. With each transaction, Xeta nodes broadcast the resulting state (new to and from balances), representing their vote about the outcome. The updated state offers clients a running balance which provides an easy way to audit transaction histories without knowing about all prior transactions or global balance states. If clients don't trust publishing nodes with transactions (or need to perform audits for their own reasons), they can openly confirm balances as many steps back as they require based on their desired confidence level. The simplest audit that a client can perform is requesting the two prior transactions affecting from/to addresses of the transaction to be verified. Clients can confirm that a certain \"UTXO\" existed and was correctly reflected by the new transaction. This functionality can be performed through a public API and interface provided by Xeta read-only nodes so that anyone can participate and make use of this validation methodology when desired. Blockless Ledger Xeta nodes validate and process every transaction individually, rather than agreeing on the validity of a group of transactions within a block. In practice, this means Xeta is blockless or that every transaction can be treated as a block of one. This allows Xeta to produce a continuous data structure of transactions (public ledger) and states (public balances). The benefit for applications is the easy access of transaction history and state of balances at any given point in time while being able to verify the integrity of each transaction (proof of audit).","title":"Permissionless Validation"},{"location":"whitepaper/#xeta-consensus","text":"Xeta Byzantine Fault Tolerance Xeta builds on top of the original BFT mechanism proposed by Lamport, Shostak, and Pease and the Practical Byzantine Fault Tolerance (PBFT) approach proposed by Castro and Liskov. We propose a modified mechanism following four progressive rounds for every transaction: proposal, voting, quorum, synchronization. 1. Proposal Any node automatically becomes a leader if it submits the first confirmation for a transaction (resulting balances and reflected state). N Nodes propose their solution to the coordinator client, which registers the first confirming node as leader/authority for the transaction to be confirmed. 2. Voting All subsequent votes (within the acceptable voting window of 1500ms after the transaction has been broadcasted) confirm the leader's vote or object in case their proposed state differs from the leaders' solution. Once confirmations of all participating nodes arrive or the window of 1500ms expires, the voting is considered complete. 3.1 Quorum (total agreement) Usually, transactions are confirmed without conflicts, meaning all nodes confirm the same states as the leader node. In this case, the transaction fee is distributed to all participating nodes. The leader receives at least 10%, while all other nodes share the fee reminder proportionally. 3.2 Quorum (partial agreement) A transaction is also considered confirmed if the weight of confirmations vs. objections is at least 4/5. The weight of each vote is a function of the staked amount by voting nodes multiplied by a factor for length of operation. The node(s) who objected (with <1/5 weight) are deducted a penalty of 0.1-Objection Weight/500 of their staked amount, which is distributed at synchronization step among the then-majority. 3.3 Quorum (non-agreement) If a vote does not reach 4/5 voting weight, it is considered unconfirmed and is rebroadcasted by the coordinator node so that all nodes can resubmit their votes. The same penalty of 0.1-Objection Weight/500 is applied on every round of rebroadcasting to all nodes who object until an agreement (4/5 majority) is reached. Voting nodes can decide to change their initial vote or drop out (by themselves or when staking requirements fall below minimum). 4. Synchronization After a transaction has been confirmed, it is pushed to all nodes, which might update their ledgers based on the outcome (if they have not voted correctly already, or if they are nodes interested in the partition range of the transaction). If a transaction has amassed a penalty balance (due to objecting nodes), it is distributed to the majority (which could flip during voting/rebroadcasting, so penalties are not distributed at every voting round but only after final confirmation). Validator Staking Requirements Nodes who want to participate in the confirmation of transactions have to stake at least 1,000,000 XETA. Our current fee structure allows approximately 50 nodes to participate economically while financing the underlying infrastructure and making a profit. Xeta BFT Conclusion Xeta BFT incentivizes high throughput, low latency, and energy efficiency (unlike PoW mechanisms). Additionally, it guarantees the finality of transactions after the self-imposed maximum confirmation window of 1500ms closes. Lastly, this mechanism ensures that the network functions under a certain amount of faulty nodes (whether unintentionally by being out of sync with the current state or by their intention to harm the network).","title":"Xeta Consensus"},{"location":"whitepaper/#mempool-nodes","text":"Xeta Mempool Double spending is the biggest problem for distributed networks like Bitcoin or Ethereum. A \"double spend\" occurs when transactions arrive in different orders on different nodes. Think about a transaction, sending 10 XETA from wallet A to B, and another transaction sending 10 XETA from wallet A to C. Assuming wallet A has only 10 XETA, one of these two transactions must fail by default. However, hypothetically, if both transactions are submitted to different nodes in different orders, a double spend occurs (assuming nodes don't coordinate between each other - which is precisely what consensus mechanisms are designed to do). The Xeta Mempool is a global pub/sub system for all incoming transactions and is responsible for broadcasting these transactions to all subscribing pools. It provides an agreed-upon ordering for messages, which solves the double-spending problem. Additionally, the Xeta Mempool involves multiple fallback mechanisms to avoid a single point of failure. The current limitations of our implementation are 80k TPS and that no prioritization of transactions is possible. Additionally, transactions cannot be reshuffled or moved ahead by paying a higher fee. These attributes are intentionally waived in favor of efficient one-way sorting with higher throughput. TLDR : The Xeta Mempool is a high throughput pub/sub mechanism that ensures the sorting of transactions by order of arrival and broadcasts them to subscribing nodes that process transactions, vote on transaction outcomes, synchronize their state-ledgers, and submit confirmations. Mempool Subscribers The Xeta Mempool receives all incoming transactions and broadcasts them to subscribing nodes. Nodes can listen selectively based on their requirements and preferences (e.g., nodes might want to listen only to transactions with from-address ranges 1-9a-z and to-address ranges from A-Z). This is a purely illustrative example based on the base58 encoding range of addresses. Nodes subscribe to the Mempool, which broadcasts all incoming transactions sequentially ordered by received-at-timestamp. Messages trigger serverless compute functions, which execute modules and programs (either simple transfer, or pre-programmed functions like auctions, staking, swapping, voting, etc.) and update states of balances. Once nodes complete the computation and state reflection internally, they broadcast the result to the coordinator node and are rewarded a portion of the transaction fee upon success. Node Synchronization Nodes subscribe to the Xeta Mempool to receive incoming transactions and update them locally. Depending on different node types (read-only API node or confirmation node), nodes can participate in receiving all transactions or listen selectively and filter for specific segments. Nodes keep a local ledger and submit confirmations to balance updates they believe are correct (to participate in the transaction fee payout). Additionally, nodes consume confirmed transactions, which allows them to update the resulting to & from states locally without having kept a prior ledger. Nodes keep track of transactions internally via an incrementing number, allowing them to stay in sync and detect missed transactions. In the case of discrepancies between a local index and the one of a last broadcasted transaction, nodes can resync and replay transactions they have missed. TLDR: Xeta provides a single data structure of all records, including all states over time. This allows nodes to sync and validate the integrity of transactions at any point in time without knowledge about prior transactions or the state of balances. Node Types Xeta has four node types: coordinator nodes, validator nodes, storage nodes, audit nodes. Coordinator nodes are mediators over the voting process, which receive votes from validator nodes and submit confirmations/rebroadcast transactions, dependent on different quorum outcomes. Every validator node can become a coordinator node if agreed upon by 4/5th of the majority. Validator nodes subscribe to transactions and store a subset of transactions (depending on their preferences or limitations, e.g., different infrastructure limits imposed by certain cloud providers). Validator nodes then execute the transaction instructions and programs, reflect state locally, and submit the reflected state as their vote. The reward for validator nodes is either 0.9/(N-1)*fee if they confirm the authority/leader node or 10% if they are the first submitting node. Storage nodes subscribe to all transactions and store them on serverless storage offerings for hypothetically infinite scalability. Storage nodes provide clients with the ability to access historical balances/transactions. Audit nodes perform audits of transactions and balances by requesting historical data from storage nodes and confirming balances. Audits can be performed as many transactions back as necessary and required by applications (up to the genesis transaction of each asset). Clients can perform audits in their browsers by requesting the required data from storage nodes.","title":"Mempool &amp; Nodes"},{"location":"whitepaper/#risks-attack-vectors","text":"51% Attack Attackers are guaranteed to be penalized a portion of their stake with every false vote they submit as confirmation. Confirming nodes have a staked amount (minimum 1,000,000 XETA) which is weighted by their length of operation. The network is secure as long as honest nodes control the majority of the total voting stake. Sybil Attack Voting weight is calculated based on the staked amount and adjusted by a factor for the length of operation. The length of operation serves as a form of reputation which is impossible to fake. Xeta accounts for vote weight rather than vote counts. Hence, the number of nodes and whether owned by the same entity or different entities do not matter. Spam Attack Attackers could spam the network with valid or invalid transactions, affecting bandwidth (best case) or bandwidth and compute resources of nodes. The Xeta Mempool runs sophisticated load balancing and protection software to ensure maximal throughput of honest transactions while throttling bad actors (or clients sending transactions with false markup leading to frequent invalid transactions). Free-Riding Transaction states are broadcasted only after the confirmation is closed and finalized. Therefore nodes can not rebroadcast existing confirmations to collect fees without providing work.","title":"Risks &amp; Attack Vectors"},{"location":"whitepaper/#economics","text":"Fee Incentives All confirming nodes receive portions of the transaction fee for every successfully confirmed transaction. The leader (proposer of a transaction) is rewarded 10%, and all other nodes are rewarded 0.9/(N-1). A certain number N exists, which is the number of nodes at which the current static transaction fees provide economic reasons to operate a node. This number is approximately 50. Hence up to 50 nodes could participate economically in the voting process of each transaction. The authority/leader node (first node to confirm a transaction and propose the resulting state) receives at least 10% or 0.9/(N-1)*fee, whichever is larger. This simple but effective fee structure allows incentivization that is meaningful to the user by fostering competition between nodes (speed of confirmation, the truthfulness of confirmations). The proposed reward mechanism solves the collective action problems of currently popular networks, mainly the free-rider problem, which originates from misaligned incentives between nodes and clients. Ethereum incentivization discourages providing infrastructure, hence such a dependence on the heavily subsidized and non-economic Infura. Bitcoin discourages confirmation speed and low fees since volunteers are paying for the network infrastructure. TLDR: Xeta's fee structure incentivizes nodes to behave truthfully while contributing efficient infrastructure to the network. This solves collective action problems as experienced by Bitcoin and Ethereum.","title":"Economics"},{"location":"whitepaper/#pools-programs","text":"Programs replacing EVM Xeta prioritizes client benefits (most notably confirmation speed and low fees) rather than providing a virtualized compute platform that executes bytecode. Xeta covers major use-case programs such as locking, staking, trading, voting, etc., which find importance in applications for Metaverse, Gaming, and NFTs. Focusing on a few programs rather than providing full EVM capabilities results in faster development and easier testing. Xeta provides a limited number of pre-written programs to creators who are building on top of Xeta. Creators often are not familiar with languages like Solidity and would rather spend time implementing features than writing and testing the underlying smart contracts. Lastly, each of Xeta's pre-written programs goes through extensive testing and becomes more trustworthy with every transaction processed. This is the opposite of Ethereum/BSC, where every smart contract has to be audited with each new deployment due to the possibility of change or error. TLDR: Xeta provides native programs instead of EVM functionality to improve development speed, guarantee ease of access to creators/users, and ultimately, focus on what matters most to Xeta's mission: the adoption of Metaverse/Gaming/NFT applications. Programs Xeta focuses on Gaming and Metaverse applications that frequently require features such as auctions, voting, swapping, and similar. Xeta provides ten in-built programs available as the underlying mechanism when creating a new asset pool. Asset pools are smart contracts that send and receive transactions while executing a set of pre-written instructions tied to an underlying asset. Auctions Auctions allow anyone to offer fungible or non-fungible tokens for sale. Bids are handled by the program, and auctions are considered successful when the auction pool has no target, the target is met, or the limit is met (equivalent to an instant purchase at maximum price). Fee Delegation Fee delegation pools hold XETA tokens which can be used for transaction fee reimbursements for users transacting with that specific asset (think fee-less voting, fee-less trading, fee-less participation in airdrops). The intention behind fee delegation is to avoid passing off costs to end-users (which is not always desired). Fund Raising Fundraising pools allow creators to raise XETA until a specific target or limit is met. Successful funds distribute portions of the raised amount to the creator and the remainder to the assets' swap pool as liquidity. If a pool rate is set, the fund automatically swaps XETA to asset tokens at that specified rate directly, without the condition of having to meet a fundraising goal. Loot Loot pools allow NFT creators and games to distribute (drop) new NFTs, items, skins from a collection in a randomized and engaging way. Users can enter for free or for a fee as specified by the pool creator. Entrants receive tickets that have a certain probability of winning a random item from the loot pool. Locking Locking pools allow asset owners to lock funds for various use-cases, such as delayed payouts and vesting. Lottery Promo pools provide an airdrop/lottery mechanism, which can engage users or distribute tokens in a simple and fair way. Users can participate for free or for a fee (specified upon pool creation) and receive tickets with a certain probability to win from the prize pool. Royalty Royalty pools are set up by an asset creator who wishes to reward all or parts of his assets based on a specified daily rate. Currently, this finds application in providing NFTs with yield for holding (royalties). Staking Staking pools allow token creators to reward holders of fungible tokens, depending on lock-up length and amount. For example, a pool creator might specify a certain APY and bonus rate for his pool, deposit reward tokens, and allow users to lock up tokens into the pool who will receive rewards once their lock-up period expires. Swapping Swapping pools are pools holding XETA and the pool asset, which can be exchanged one for another. Swap pools are the same functionality that makes popular DEXs like Uniswap or PancakeSwap possible. Voting Voting pools allow users to submit votes given a list of assets/addresses or numbers (prediction markets). Voting can be used for governance (voting for new proposals), for predictions with payouts to the winning voters, or to engage users (a mechanism to vote on any tokenized objects and get paid if the vote was correct after pool expiry).","title":"Pools &amp; Programs"},{"location":"whitepaper/#xeta-reality","text":"What is Xeta Reality Xeta Reality is the overarching ecosystem consisting of Xeta (the blockchain) and various apps (mobile app for virtualization and tokenization of people and objects) and dApps (such as NFT marketplaces, DEXs, authenticity, and deduplication for NFTs). Mission Xeta's mission is to onboard 100 million users to the Metaverse by developing intuitive applications & interfaces for mainstream adoption. Focus Areas Xeta Reality focuses on promoting Metaverse, Gaming, and NFT adoption using blockchain (asset registry, virtualization, dApps) and vision AI (object detection/segmentation). The six core pillars of Xeta Reality are: Scanning and virtualizing things: Simplifying asset virtualization by building 3D scanning tools and apps to empower anyone to digitize anything anywhere. Extensive research & development of object detection and segmentation AI models. Interoperability between blockchains and realities: Enabling the exchange of fungible and non-fungible assets between common blockchains and parallel realities (physical reality, virtual worlds, omniverses). Asset registry, tokenization, and authenticity: Building a Layer-1 blockchain to simplify asset registry and tokenization of things and integrating identity, deduplication, and IP-protection middleware, specifically for NFTs and virtual items (image, video, audio). Virtual economies (DEXs, NFT marketplaces, auctions): Creation of exchanges & marketplaces for tokens, NFTs, avatars, skins, virtual properties, and virtual ad space. Provisioning \"one-click-setup\" DEXs and marketplaces using no-code interfaces. dApp ecosystem (identity, staking, 3rd party): Providing core functionality dApps (for identity, staking, etc.) using Xeta Blockchain and setting up a grant-based incentive program for 3rd party developers. Community, contributors & partnerships: Building and maintaining an active community of ambassadors, providing well-documented software to creators, and seeking partnerships with companies for collaboration and innovation around Metaverse technologies.","title":"Xeta Reality"},{"location":"whitepaper/#tokenomics","text":"Currently, there are 1 billion XETA tokens in circulation. The total circulation will be 10 billion XETA tokens. The total token circulation of 10 billion XETA tokens will be reached approximately by 2027. 1-1.5 billion XETA tokens will be in circulation on Ethereum and Binance Smart Chain (BSC), while 8.5-9B will be in circulation on the Xeta native blockchain. Bridges will make it possible to swap between these blockchains seamlessly. Allocations: 20% ecosystem & partnerships, 20% community enrichment, 15% foundation, 10% legal, marketing & biz dev, 10% future financing rounds & OTC, 10% team & development, 10% public liquidity, 5% advisors & contributors.","title":"Tokenomics"},{"location":"whitepaper/#roadmap-milestones","text":"Xeta Blockchain Q4 2021 - A lightweight modular blockchain to support asset tokenization and transactions with sub-second latencies. Block Explorer, Wallet & Metrics Q4 2021 - A block explorer, a wallet web app (mobile app shortly after), and an analytics dashboard for interacting with the Xeta Blockchain. Minting & Tokenization Interface Q1 2022 - Simplification of minting NFTs & creating tokens - enabled by a no-code interface. Staking dApp for Holders Q1 2022 - Launching the first Xeta Blockchain native dApp - a staking app rewarding holders by locking tokens for a predictable APY. 3D Scan Virtualization Q1 2022 - A mobile app that enables virtualization of anything with possibilities such as NFT/avatar creation or registry/virtualization of surroundings. Creation of DEXs/Marketplaces Q2 2022 - One-click creation of customizable DEXs (for tokens) and marketplaces (for NFT assets). Real-Time Object Segmentation Q2 2022 - Training vision AI models (on top of the current state-of-the-art models), capable of detecting and segmenting 200-300 different objects (integrated with the Xeta 3D scanning app). NFT Uniqueness & IP Protection Q2 2022 - Using methods such as Local Sensitive Hashing for deduplication/IP protection and governance mechanisms for conflict resolution. Digital Real Estate Q3 2022 - Bringing together Xeta Blockchain (land registry), 3D graphics, and our underlying APIs (storage) to virtualize and trade virtual land. dApp/Metaverse Ecosystem Q3 2022 - Expanding business development to establish partnerships and to implement Xeta Blockchain & Xeta Metaverse technology. Bridges & Interoperability Q4 2022 - Building bridges to transfer assets and tokens between various blockchains & virtual realities and allowing the import of assets from blockchains to Xeta/export from Xeta to other blockchains. Decentralized Data APIs Q4 2022 - Providing simple and well-documented APIs to developers for decentralized data storage and access.","title":"Roadmap &amp; Milestones"},{"location":"whitepaper/#join-xeta","text":"Follow us and join our community, or start building on Xeta! https://xetareality.com https://xeta.network https://t.me/XetaReality https://twitter.com/XetaReality https://www.reddit.com/r/XetaReality https://xetareality.medium.com https://github.com/XetaReality Resources https://www.theblockresearch.com/the-burden-of-infura-6899 https://bitcoin.org/bitcoin.pdf https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals-Problem.pdf https://arxiv.org/pdf/1803.05069.pdf http://pmg.csail.mit.edu/papers/osdi99.pdf https://vldb2020.org/assets/files/tutorial1_part2_system.pdf https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf","title":"Join Xeta"},{"location":"xeta-blockchain/","text":"Xeta Blockchain","title":"Xeta Blockchain"},{"location":"xeta-blockchain/#xeta-blockchain","text":"","title":"Xeta Blockchain"},{"location":"features/bridge/","text":"Bridge Intro The Xeta bridge swaps between ETH/BNB/BSC XETA and native XETA tokens, with slippage of around 1.5% (plus regular liquidity slippage for amounts that impact liquidity). This process also works vice versa. The swap process takes about 5 minutes and is completely automated in both directions. Use Cases: Swapping supported assets from Ethereum (ETH) or Binance Smart Chain (BNB, XETA) to Xeta native tokens, Swapping native Xeta tokens into assets on Ethereum (ETH) or Binance Smart Chain (BNB, XETA) Functionality The user makes an input transfer to Xeta\u2019s bridge wallet address on the chosen input chain. Xeta listens to all incoming transactions with a specifically formatted schema (the data/message field of transactions) and awaits a sufficient number of confirmations. After the transaction is confirmed, Xeta calculates the exchange rate based on swap size and its effect on liquidity to account for possible slippage. Slippage fees added on top of the base fee of 1.25%. Xeta then sends the output transfer on the chosen target chain to the wallet address connected by the user. Methods Create Bridge Request Create a new bridge request. Requirements: ETH/BSC wallet , XETA wallet Outputs: Transfer on target chain Inputs: ETH/BSC public address XETA public address Swap amount Source-chain Target-chain \\pagebreak","title":"Bridge"},{"location":"features/bridge/#bridge","text":"","title":"Bridge"},{"location":"features/bridge/#intro","text":"The Xeta bridge swaps between ETH/BNB/BSC XETA and native XETA tokens, with slippage of around 1.5% (plus regular liquidity slippage for amounts that impact liquidity). This process also works vice versa. The swap process takes about 5 minutes and is completely automated in both directions. Use Cases: Swapping supported assets from Ethereum (ETH) or Binance Smart Chain (BNB, XETA) to Xeta native tokens, Swapping native Xeta tokens into assets on Ethereum (ETH) or Binance Smart Chain (BNB, XETA)","title":"Intro"},{"location":"features/bridge/#functionality","text":"The user makes an input transfer to Xeta\u2019s bridge wallet address on the chosen input chain. Xeta listens to all incoming transactions with a specifically formatted schema (the data/message field of transactions) and awaits a sufficient number of confirmations. After the transaction is confirmed, Xeta calculates the exchange rate based on swap size and its effect on liquidity to account for possible slippage. Slippage fees added on top of the base fee of 1.25%. Xeta then sends the output transfer on the chosen target chain to the wallet address connected by the user.","title":"Functionality"},{"location":"features/bridge/#methods","text":"","title":"Methods"},{"location":"features/bridge/#create-bridge-request","text":"Create a new bridge request. Requirements: ETH/BSC wallet , XETA wallet Outputs: Transfer on target chain Inputs: ETH/BSC public address XETA public address Swap amount Source-chain Target-chain \\pagebreak","title":"Create Bridge Request"},{"location":"features/faucet/","text":"Faucet Intro Xeta\u2019s Faucet allows users to request a certain number of free XETA tokens on the Mainnet and Testnet. It allows users and creators to try out Xeta without purchasing or swapping tokens. Use Cases: Create a few simple transactions on Mainnet Create, test, and launch any desired functionalities on Testnet Functionality Users who own a Gmail address can request free XETA tokens from the faucet feature. The user needs to confirm their email, after which the Faucet automatically makes two transfers to the users\u2019 connected wallet, one on Mainnet and one on Testnet. Methods Create Faucet Request Create a faucet request and receive tokens on Mainnet and Testnet. Requirements: Valid Gmail address , Xeta wallet Outputs: XETA transfer from faucet to wallet on Mainnet , XETA transfer to from faucet wallet on Testnet Inputs: None \\pagebreak","title":"Faucet"},{"location":"features/faucet/#faucet","text":"","title":"Faucet"},{"location":"features/faucet/#intro","text":"Xeta\u2019s Faucet allows users to request a certain number of free XETA tokens on the Mainnet and Testnet. It allows users and creators to try out Xeta without purchasing or swapping tokens. Use Cases: Create a few simple transactions on Mainnet Create, test, and launch any desired functionalities on Testnet","title":"Intro"},{"location":"features/faucet/#functionality","text":"Users who own a Gmail address can request free XETA tokens from the faucet feature. The user needs to confirm their email, after which the Faucet automatically makes two transfers to the users\u2019 connected wallet, one on Mainnet and one on Testnet.","title":"Functionality"},{"location":"features/faucet/#methods","text":"","title":"Methods"},{"location":"features/faucet/#create-faucet-request","text":"Create a faucet request and receive tokens on Mainnet and Testnet. Requirements: Valid Gmail address , Xeta wallet Outputs: XETA transfer from faucet to wallet on Mainnet , XETA transfer to from faucet wallet on Testnet Inputs: None \\pagebreak","title":"Create Faucet Request"},{"location":"features/sponsorship/","text":"Sponsorship Intro Xeta enables users to transfer a sponsored balance to addresses or pools, so other users interacting with these resources can do so without paying network fees. Use Cases: Recipient sponsoring incoming transfers to their address Pool sponsoring incoming transfers and enabling participation without owning XETA Project creators who would like to encourage participation in particular pools Functionality A user transfers sponsored XETA tokens to an address or pool. The transferred token is specified as sponsored XETA and is automatically swapped from the users' XETA balance into sponsored XETA and credited to the resource. Other users who interact with the sponsored resource won't be charged any fees until the sponsored balance of the resource is depleted. Methods Create Swaps the users' owned XETA into sponsored XETA. Sponsored XETA cannot be withdrawn. Requirements: XETA balance Outputs: Sponsored XETA transfer from sender to recipient Inputs: To - Recipient resource to be sponsored Token - Must be specified as 1111111111111111111111111sponsored Amount - Amount to sponsor From - From address in case of allowance Message - Custom transfer message \\pagebreak","title":"Sponsorship"},{"location":"features/sponsorship/#sponsorship","text":"","title":"Sponsorship"},{"location":"features/sponsorship/#intro","text":"Xeta enables users to transfer a sponsored balance to addresses or pools, so other users interacting with these resources can do so without paying network fees. Use Cases: Recipient sponsoring incoming transfers to their address Pool sponsoring incoming transfers and enabling participation without owning XETA Project creators who would like to encourage participation in particular pools","title":"Intro"},{"location":"features/sponsorship/#functionality","text":"A user transfers sponsored XETA tokens to an address or pool. The transferred token is specified as sponsored XETA and is automatically swapped from the users' XETA balance into sponsored XETA and credited to the resource. Other users who interact with the sponsored resource won't be charged any fees until the sponsored balance of the resource is depleted.","title":"Functionality"},{"location":"features/sponsorship/#methods","text":"","title":"Methods"},{"location":"features/sponsorship/#create","text":"Swaps the users' owned XETA into sponsored XETA. Sponsored XETA cannot be withdrawn. Requirements: XETA balance Outputs: Sponsored XETA transfer from sender to recipient Inputs: To - Recipient resource to be sponsored Token - Must be specified as 1111111111111111111111111sponsored Amount - Amount to sponsor From - From address in case of allowance Message - Custom transfer message \\pagebreak","title":"Create"},{"location":"features/wallet/","text":"Wallet Intro Xeta\u2019s wallet allows users to create and manage their XETA blockchain wallets, either by managing keys yourself or letting a 3rd party provider (currently Xeta foundation) manage keys for you. Use Cases: Create a new self-managed or managed Xeta wallet Connect an existing self-managed or managed Xeta wallet Functionality Users need a wallet to interact with the Xeta blockchain. Users can create a key pair (public key/private key) or let a provider manage this keypair for them (using a more memorable account and secret). Once a wallet is created through the self-managed or managed option, it can be connected to Xeta\u2019s apps, as long as the owner has access to the private key or account and secret (in the case of managed keys). Methods Create Self-Managed Create a new XETA blockchain key pair. Requirements: None Outputs: Public key , Private key Inputs: None Create Managed Create a managed wallet. Requirements: None Outputs: Public key Inputs: Account - Memorable account name, for example, email, phone number, or username Secret - Memorable password Connect Self-Managed Connect a self-managed wallet. Requirements: Private key Outputs: None Inputs: None Connect Managed Connect a managed wallet. Requirements: Account name , Account secret Outputs: None Inputs: None \\pagebreak","title":"Wallet"},{"location":"features/wallet/#wallet","text":"","title":"Wallet"},{"location":"features/wallet/#intro","text":"Xeta\u2019s wallet allows users to create and manage their XETA blockchain wallets, either by managing keys yourself or letting a 3rd party provider (currently Xeta foundation) manage keys for you. Use Cases: Create a new self-managed or managed Xeta wallet Connect an existing self-managed or managed Xeta wallet","title":"Intro"},{"location":"features/wallet/#functionality","text":"Users need a wallet to interact with the Xeta blockchain. Users can create a key pair (public key/private key) or let a provider manage this keypair for them (using a more memorable account and secret). Once a wallet is created through the self-managed or managed option, it can be connected to Xeta\u2019s apps, as long as the owner has access to the private key or account and secret (in the case of managed keys).","title":"Functionality"},{"location":"features/wallet/#methods","text":"","title":"Methods"},{"location":"features/wallet/#create-self-managed","text":"Create a new XETA blockchain key pair. Requirements: None Outputs: Public key , Private key Inputs: None","title":"Create Self-Managed"},{"location":"features/wallet/#create-managed","text":"Create a managed wallet. Requirements: None Outputs: Public key Inputs: Account - Memorable account name, for example, email, phone number, or username Secret - Memorable password","title":"Create Managed"},{"location":"features/wallet/#connect-self-managed","text":"Connect a self-managed wallet. Requirements: Private key Outputs: None Inputs: None","title":"Connect Self-Managed"},{"location":"features/wallet/#connect-managed","text":"Connect a managed wallet. Requirements: Account name , Account secret Outputs: None Inputs: None \\pagebreak","title":"Connect Managed"},{"location":"modules/address/","text":"Address Intro An address represents an account on Xeta and is either a token, pool or private wallet. Every public key is automatically an address that can receive funds, and users can customize their address profiles with name, description, links, image previews, and other info. Use Cases: Token and pool addresses Personal wallet address (equivalent to a public key) Custom profiles (such as an address representing an NFT collection) Functionality When a user creates a managed or self-managed wallet, a public key is automatically generated, serving as a public wallet address. This address is public and can receive permissionless transfers from anyone. A user can update their connected wallet address to represent a profile or a collection. Methods Update Address Update an address by adding custom info such as name, preview image, etc. Requirements: Xeta wallet Outputs: NFT representing profile data Inputs: Name - a name for the address Description - a description for the address Links - profile links Meta - profile data as a JSON object Preview - preview image for the address Category - category of the address \\pagebreak","title":"Address"},{"location":"modules/address/#address","text":"","title":"Address"},{"location":"modules/address/#intro","text":"An address represents an account on Xeta and is either a token, pool or private wallet. Every public key is automatically an address that can receive funds, and users can customize their address profiles with name, description, links, image previews, and other info. Use Cases: Token and pool addresses Personal wallet address (equivalent to a public key) Custom profiles (such as an address representing an NFT collection)","title":"Intro"},{"location":"modules/address/#functionality","text":"When a user creates a managed or self-managed wallet, a public key is automatically generated, serving as a public wallet address. This address is public and can receive permissionless transfers from anyone. A user can update their connected wallet address to represent a profile or a collection.","title":"Functionality"},{"location":"modules/address/#methods","text":"","title":"Methods"},{"location":"modules/address/#update-address","text":"Update an address by adding custom info such as name, preview image, etc. Requirements: Xeta wallet Outputs: NFT representing profile data Inputs: Name - a name for the address Description - a description for the address Links - profile links Meta - profile data as a JSON object Preview - preview image for the address Category - category of the address \\pagebreak","title":"Update Address"},{"location":"modules/allowance/","text":"Allowance Intro An allowance can be given to another address, which is then allowed to spend a particular fungible token amount on behalf of the creator. Use Case: Allowing someone to spend funds on your behalf Functionality A user sets an allowance, granting another spender the right to spend a particular fungible token for a certain amount. The spender then can create transfers by specifying the from address to be the address that granted the allowance. The allowance creator can increase and decrease their given allowances at any time. The spender can make transfers until the creator\u2019s allowance is depleted or adjusted to zero. Methods Update Allowance Allows a spender to spend your tokens for the specified amount. Requirements: Token balance Outputs: Allowance to spend Inputs: Spender - Public address of the spender Token - Fungible-token address Amount - Allowance amount \\pagebreak","title":"Allowance"},{"location":"modules/allowance/#allowance","text":"","title":"Allowance"},{"location":"modules/allowance/#intro","text":"An allowance can be given to another address, which is then allowed to spend a particular fungible token amount on behalf of the creator. Use Case: Allowing someone to spend funds on your behalf","title":"Intro"},{"location":"modules/allowance/#functionality","text":"A user sets an allowance, granting another spender the right to spend a particular fungible token for a certain amount. The spender then can create transfers by specifying the from address to be the address that granted the allowance. The allowance creator can increase and decrease their given allowances at any time. The spender can make transfers until the creator\u2019s allowance is depleted or adjusted to zero.","title":"Functionality"},{"location":"modules/allowance/#methods","text":"","title":"Methods"},{"location":"modules/allowance/#update-allowance","text":"Allows a spender to spend your tokens for the specified amount. Requirements: Token balance Outputs: Allowance to spend Inputs: Spender - Public address of the spender Token - Fungible-token address Amount - Allowance amount \\pagebreak","title":"Update Allowance"},{"location":"modules/claim/","text":"Claim Intro Claims represent a promise or contract that is made between two parties. A claim creator issues a claim to someone representing an option that can be redeemed based on specified terms such as timeframe or amount. The claim owner can redeem the claim once the condition of the claim is met. The fulfillment of promises made by claims is not guaranteed and is dependent on the issuers\u2019 integrity and trust. However, if a pool with a verifiable program issues the claim, the claim resolution can be guaranteed through code. Use Cases: Claims between two users (credit claims, ownership claims, contracts, promises) Claims between a pool and a user (liquidity claim, deposit claim, vote claim, lottery ticket claim, etc.) Functionality A claim creator creates a claim based on a specific agreement and issues it to a user who has the right to claim once the conditions are met. Most frequently, pools use claims as a ticket to the user, who can redeem the ticket. Created claims can be updated by the creator at any time until resolution. Claim creators can also mark claims as resolved, at which point the claim becomes settled and cannot be updated any longer. Owned claims can be transferred as long as they are not frozen. Methods Create Enables a pool or user to issue a claim to someone. Requirements: Claim token balance/ownership Outputs: Claim assigned to specified owner Inputs: Owner - Holder who receives the claim Token - Claimable token TokenAmount - Claimable token amount XetaAmount - Claimable Xeta amount Expires - Expiry date for the claim Unlocks - Date at which the claim becomes claimable Frozen - Forbids claim transfers, if set to true Category - Claim category Meta - Custom metadata as a JSON object Answer - Claimed answer Number - Claimed number Transfer Enables the claim owner to transfer claim ownership. Requirements: Unfrozen claim Outputs: None Inputs: Claim - Claim hash To - To address Update Enables the claim creator to update specific claim values. Requirements: Claim creator Outputs: None Inputs: Claim - Claim hash TokenAmount - Claimable token amount XetaAmount - Claimable Xeta amount Expires - Expiry date for the claim Unlocks - Date at which the claim becomes claimable Frozen - Forbids claim transfers, if set to true Category - Claim category Meta - Custom metadata as a JSON object Answer - Claimed answer Number - Claimed number Resolve Enables the claim creator to close a claim and tag it as resolved. Requirements: Claim creator Outputs: None Inputs: Claim - Claim hash \\pagebreak","title":"Claim"},{"location":"modules/claim/#claim","text":"","title":"Claim"},{"location":"modules/claim/#intro","text":"Claims represent a promise or contract that is made between two parties. A claim creator issues a claim to someone representing an option that can be redeemed based on specified terms such as timeframe or amount. The claim owner can redeem the claim once the condition of the claim is met. The fulfillment of promises made by claims is not guaranteed and is dependent on the issuers\u2019 integrity and trust. However, if a pool with a verifiable program issues the claim, the claim resolution can be guaranteed through code. Use Cases: Claims between two users (credit claims, ownership claims, contracts, promises) Claims between a pool and a user (liquidity claim, deposit claim, vote claim, lottery ticket claim, etc.)","title":"Intro"},{"location":"modules/claim/#functionality","text":"A claim creator creates a claim based on a specific agreement and issues it to a user who has the right to claim once the conditions are met. Most frequently, pools use claims as a ticket to the user, who can redeem the ticket. Created claims can be updated by the creator at any time until resolution. Claim creators can also mark claims as resolved, at which point the claim becomes settled and cannot be updated any longer. Owned claims can be transferred as long as they are not frozen.","title":"Functionality"},{"location":"modules/claim/#methods","text":"","title":"Methods"},{"location":"modules/claim/#create","text":"Enables a pool or user to issue a claim to someone. Requirements: Claim token balance/ownership Outputs: Claim assigned to specified owner Inputs: Owner - Holder who receives the claim Token - Claimable token TokenAmount - Claimable token amount XetaAmount - Claimable Xeta amount Expires - Expiry date for the claim Unlocks - Date at which the claim becomes claimable Frozen - Forbids claim transfers, if set to true Category - Claim category Meta - Custom metadata as a JSON object Answer - Claimed answer Number - Claimed number","title":"Create"},{"location":"modules/claim/#transfer","text":"Enables the claim owner to transfer claim ownership. Requirements: Unfrozen claim Outputs: None Inputs: Claim - Claim hash To - To address","title":"Transfer"},{"location":"modules/claim/#update","text":"Enables the claim creator to update specific claim values. Requirements: Claim creator Outputs: None Inputs: Claim - Claim hash TokenAmount - Claimable token amount XetaAmount - Claimable Xeta amount Expires - Expiry date for the claim Unlocks - Date at which the claim becomes claimable Frozen - Forbids claim transfers, if set to true Category - Claim category Meta - Custom metadata as a JSON object Answer - Claimed answer Number - Claimed number","title":"Update"},{"location":"modules/claim/#resolve","text":"Enables the claim creator to close a claim and tag it as resolved. Requirements: Claim creator Outputs: None Inputs: Claim - Claim hash \\pagebreak","title":"Resolve"},{"location":"modules/pool/","text":"Pool Intro Pools are autonomous accounts that execute a set of programmed instructions. Pools are generic wrappers for assets to enable decentralized functionalities such as auctions, launches, lending, locks, loots, lotteries, royalties, staking, swaps, and votes. Pools can hold tokens, make transfers, and create claims based on their underlying and specified program chosen at pool creation. Use Cases: Reusable autonomous wrappers which execute programmable instructions (equivalent to smart contracts), enabling DeFi functionalities like auctions, launches, lending, locks, loots, lotteries, royalties, staking, swaps, and votes Functionality A user creates a pool for a particular token while specifying the desired pool program. This program can be specified as auction (creating an NFT auction), launch (launch-pads for new tokens), lending (allowing others to borrow tokens against XETA collateral), locks (locking/vesting tokens), loot (randomized token drops), lottery (token lotteries), royalty (rewards for NFTs), swap (decentralized exchange), vote (voting/betting mechanisms) or any custom program as written in Xeta\u2019s Turing-incomplete programming language. During pool creation, the user might configure the pool using predefined parameters and modify how program instructions are executed (for example, by specifying a minAmount, the pool might only accept transfers with a certain amount). Methods Create Create a new pool that executes instructions based on the specified program for a specified token. Requirements: Token balance/ownership Outputs: Pool for the specified token Inputs: Token - Token for the pool Program - Pool program id Name - Name of the pool Description - Description of the pool Mechanism - Mechanism, as required by specific programs Candidates - List of candidates Rate - Rate between 0-1 Percentage - Percentage, between 0-1 Number - Custom number as required by specific programs Answers - List of answers Meta - Custom metadata as a JSON object Expires - Datetime of expiry MinAmount - Min. amount for transfers to the pool MaxAmount - Max. amount for transfers to the pool MinTime - Min. time of claims created by the pool MaxTime - Max. time of claims created by the pool TransfersLimit - Max. number of transfers to the pool ClaimsLimit - Max. number of claims by the pool TokenTarget - Token target balance of the pool XetaTarget - Xeta target balance of the pool TokenLimit - Token limit balance of the pool XetaLimit - Xeta limit balance of the pool \\pagebreak","title":"Pool"},{"location":"modules/pool/#pool","text":"","title":"Pool"},{"location":"modules/pool/#intro","text":"Pools are autonomous accounts that execute a set of programmed instructions. Pools are generic wrappers for assets to enable decentralized functionalities such as auctions, launches, lending, locks, loots, lotteries, royalties, staking, swaps, and votes. Pools can hold tokens, make transfers, and create claims based on their underlying and specified program chosen at pool creation. Use Cases: Reusable autonomous wrappers which execute programmable instructions (equivalent to smart contracts), enabling DeFi functionalities like auctions, launches, lending, locks, loots, lotteries, royalties, staking, swaps, and votes","title":"Intro"},{"location":"modules/pool/#functionality","text":"A user creates a pool for a particular token while specifying the desired pool program. This program can be specified as auction (creating an NFT auction), launch (launch-pads for new tokens), lending (allowing others to borrow tokens against XETA collateral), locks (locking/vesting tokens), loot (randomized token drops), lottery (token lotteries), royalty (rewards for NFTs), swap (decentralized exchange), vote (voting/betting mechanisms) or any custom program as written in Xeta\u2019s Turing-incomplete programming language. During pool creation, the user might configure the pool using predefined parameters and modify how program instructions are executed (for example, by specifying a minAmount, the pool might only accept transfers with a certain amount).","title":"Functionality"},{"location":"modules/pool/#methods","text":"","title":"Methods"},{"location":"modules/pool/#create","text":"Create a new pool that executes instructions based on the specified program for a specified token. Requirements: Token balance/ownership Outputs: Pool for the specified token Inputs: Token - Token for the pool Program - Pool program id Name - Name of the pool Description - Description of the pool Mechanism - Mechanism, as required by specific programs Candidates - List of candidates Rate - Rate between 0-1 Percentage - Percentage, between 0-1 Number - Custom number as required by specific programs Answers - List of answers Meta - Custom metadata as a JSON object Expires - Datetime of expiry MinAmount - Min. amount for transfers to the pool MaxAmount - Max. amount for transfers to the pool MinTime - Min. time of claims created by the pool MaxTime - Max. time of claims created by the pool TransfersLimit - Max. number of transfers to the pool ClaimsLimit - Max. number of claims by the pool TokenTarget - Token target balance of the pool XetaTarget - Xeta target balance of the pool TokenLimit - Token limit balance of the pool XetaLimit - Xeta limit balance of the pool \\pagebreak","title":"Create"},{"location":"modules/token/","text":"Token Intro Tokens are fungible (divisible) or non-fungible assets. Fungible tokens are similar to shares and represent fractional ownership of something. Non-fungible tokens represent objects via object URL (IPFS, S3, etc) or content hash (e.g. MD5 of bytes content). Use Cases: Fungible tokens (representing fractional ownership of something) Non-fungible tokens (representing objects via URL or content hash in physical and virtual worlds) Functionality A user can mint fungible or non-fungible tokens. Fungible tokens represent fractional shares and have a symbol, supply, and optionally a reserve, which can be used to mint additional tokens at a later point in time. Non-fungible tokens represent objects in physical and virtual spaces by referencing an object URL (e.g. IPFS link) or a content hash. When fungible tokens are minted, a decentralized swap pool is created automatically, enabling the decentralized exchange of tokens. Methods Create Create a fungible or non-fungible token. Requirements: None Outputs: Funigble or non-fungible token Inputs: Name - Name of the token Description - Description of the token Links - Links for the token Meta - Custom metadata as a JSON object Preview - Preview image for the token, e.g. icon for FT, image for NFT Symbol - Symbol for FT Supply - Supply for FT Reserve - Reserve for FT, mintable at a later point in time Owner - Owner for NFT Object - Object representing NFT Content - Content representing NFT Mime - Mime of NFT object Frozen - Disables transfer of NFT, if true Category - NFT category Update Allows the creator to update a fungible or non-fungible token. Requirements: Token creator Outputs: None Inputs: Token - Token address Name - Update name Description - Updated description Links - Updated links Meta - Updated meta Preview - Updated image preview Mime - Updated object mime Frozen - Frozen NFT status Category - Updated NFT category Mint Allows the creator of a fungible token to mint additional tokens from its unallocated reserve. Requirements: Token creator Outputs: Token transfer from factory to creator Inputs: Token - Token address Amount - Amount to be minted \\pagebreak","title":"Token"},{"location":"modules/token/#token","text":"","title":"Token"},{"location":"modules/token/#intro","text":"Tokens are fungible (divisible) or non-fungible assets. Fungible tokens are similar to shares and represent fractional ownership of something. Non-fungible tokens represent objects via object URL (IPFS, S3, etc) or content hash (e.g. MD5 of bytes content). Use Cases: Fungible tokens (representing fractional ownership of something) Non-fungible tokens (representing objects via URL or content hash in physical and virtual worlds)","title":"Intro"},{"location":"modules/token/#functionality","text":"A user can mint fungible or non-fungible tokens. Fungible tokens represent fractional shares and have a symbol, supply, and optionally a reserve, which can be used to mint additional tokens at a later point in time. Non-fungible tokens represent objects in physical and virtual spaces by referencing an object URL (e.g. IPFS link) or a content hash. When fungible tokens are minted, a decentralized swap pool is created automatically, enabling the decentralized exchange of tokens.","title":"Functionality"},{"location":"modules/token/#methods","text":"","title":"Methods"},{"location":"modules/token/#create","text":"Create a fungible or non-fungible token. Requirements: None Outputs: Funigble or non-fungible token Inputs: Name - Name of the token Description - Description of the token Links - Links for the token Meta - Custom metadata as a JSON object Preview - Preview image for the token, e.g. icon for FT, image for NFT Symbol - Symbol for FT Supply - Supply for FT Reserve - Reserve for FT, mintable at a later point in time Owner - Owner for NFT Object - Object representing NFT Content - Content representing NFT Mime - Mime of NFT object Frozen - Disables transfer of NFT, if true Category - NFT category","title":"Create"},{"location":"modules/token/#update","text":"Allows the creator to update a fungible or non-fungible token. Requirements: Token creator Outputs: None Inputs: Token - Token address Name - Update name Description - Updated description Links - Updated links Meta - Updated meta Preview - Updated image preview Mime - Updated object mime Frozen - Frozen NFT status Category - Updated NFT category","title":"Update"},{"location":"modules/token/#mint","text":"Allows the creator of a fungible token to mint additional tokens from its unallocated reserve. Requirements: Token creator Outputs: Token transfer from factory to creator Inputs: Token - Token address Amount - Amount to be minted \\pagebreak","title":"Mint"},{"location":"modules/transfer/","text":"Transfer Intro A transfer allows the transfer of fungible and non-fungible tokens between addresses. Use Cases: Transferring an amount of a fungible token Transferring a non-fungible token Functionality A user with a certain fungible-token balance can transfer all or parts of the balance to another address. Additionally, a user who owns a particular non-fungible token can create a transfer to assign ownership to another address. Methods Create Create a new fungible or non-fungible token transfer. Requirements: Token balance/ownership Outputs: Token transfer from sender to recipient Inputs: To - To address for the transfer Token - Token to be transferred Amount - Transfer amount for FT, empty if NFT From - From address in case of allowance Message - Custom transfer message \\pagebreak","title":"Transfer"},{"location":"modules/transfer/#transfer","text":"","title":"Transfer"},{"location":"modules/transfer/#intro","text":"A transfer allows the transfer of fungible and non-fungible tokens between addresses. Use Cases: Transferring an amount of a fungible token Transferring a non-fungible token","title":"Intro"},{"location":"modules/transfer/#functionality","text":"A user with a certain fungible-token balance can transfer all or parts of the balance to another address. Additionally, a user who owns a particular non-fungible token can create a transfer to assign ownership to another address.","title":"Functionality"},{"location":"modules/transfer/#methods","text":"","title":"Methods"},{"location":"modules/transfer/#create","text":"Create a new fungible or non-fungible token transfer. Requirements: Token balance/ownership Outputs: Token transfer from sender to recipient Inputs: To - To address for the transfer Token - Token to be transferred Amount - Transfer amount for FT, empty if NFT From - From address in case of allowance Message - Custom transfer message \\pagebreak","title":"Create"},{"location":"programs/auction/","text":"Auction Intro Auctions allow users to offer non-fungible tokens for sale. Participants can submit XETA-bids until the auction expires or the XETA limit is reached. Auction programs automatically handle the resolution by transferring the highest bid and NFT to their new or previous owners (depending on the auction status). Use Cases: Auctioning an NFT that a user owns in exchange for XETA Functionality The NFT owner creates an auction pool and sets a XETA target (minimum bid to consider the auction successful), a limit value (instant-buy bid), and a time of expiration. The NFT owner then deposits the NFT to the auction pool, and participants can place bids to the auction pool. When a participant places a bid higher than the previous bid, the pool automatically returns the earlier bid to the previous leader. The auction outcome is determined when the auction expires or when the limit bid is reached before the expiration time. An auction is considered successful when the limit bid is reached before expiration, or when the target bid is reached at the time of expiration. Auction pools charge a commission of 2.5% for every concluded auction. Upon success/failure of the auction, any Xeta user can call the resolve/cancel method of the auction pool, which then handles the asset transfers to the new or old owners. On auction failure (target bid not reached on expiry), the NFT is returned to the pool creator, and the highest bid is returned to the highest bidder. On auction success, the NFT is transferred to the highest bidder, and the highest bid is transferred to the auction-pool creator. Methods Transfer Transfer a XETA bid to the auction pool. Requirements: Bid higher than previous bid Outputs: Bid transfer from sender to pool , Return transfer from pool to previous highest bidder Inputs: Amount - Bid amount Resolve Resolve a successfully concluded auction pool. Requirements: Pool closed or expired and bid >= xetaTarget , Pool active and bid = xetaLimit Outputs: NFT transfer from pool to highest bidder , XETA transfer from pool to pool creator Inputs: None Cancel Cancel an unsuccessful auction pool. Requirements: Pool closed or expired and bid < xetaTarget Outputs: NFT transfer from pool to pool creator , XETA transfer from pool to highest bidder Inputs: None Create Create an auction pool for a particular NFT. Requirements: Pool creator , Pool token ownership Outputs: Auction pool Inputs: Token - NFT address XetaTarget - Minimum bid for auction to be considered successful upon expiry XetaLimit - Maximum bid, equivalent to instant-buy bid TransfersLimit - Maximum limit of transfers Expires - Date and time of expiry Deposit Deposit an NFT to the auction pool. Requirements: Pool creator , Pool token ownership Outputs: NFT transfer from sender to pool Inputs: Unlocks - Datetime when NFT claim can be unlocked and withdrawn Close Closes an auction before expiry. Allows anyone to call cancel or resolve methods immediately. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Auction"},{"location":"programs/auction/#auction","text":"","title":"Auction"},{"location":"programs/auction/#intro","text":"Auctions allow users to offer non-fungible tokens for sale. Participants can submit XETA-bids until the auction expires or the XETA limit is reached. Auction programs automatically handle the resolution by transferring the highest bid and NFT to their new or previous owners (depending on the auction status). Use Cases: Auctioning an NFT that a user owns in exchange for XETA","title":"Intro"},{"location":"programs/auction/#functionality","text":"The NFT owner creates an auction pool and sets a XETA target (minimum bid to consider the auction successful), a limit value (instant-buy bid), and a time of expiration. The NFT owner then deposits the NFT to the auction pool, and participants can place bids to the auction pool. When a participant places a bid higher than the previous bid, the pool automatically returns the earlier bid to the previous leader. The auction outcome is determined when the auction expires or when the limit bid is reached before the expiration time. An auction is considered successful when the limit bid is reached before expiration, or when the target bid is reached at the time of expiration. Auction pools charge a commission of 2.5% for every concluded auction. Upon success/failure of the auction, any Xeta user can call the resolve/cancel method of the auction pool, which then handles the asset transfers to the new or old owners. On auction failure (target bid not reached on expiry), the NFT is returned to the pool creator, and the highest bid is returned to the highest bidder. On auction success, the NFT is transferred to the highest bidder, and the highest bid is transferred to the auction-pool creator.","title":"Functionality"},{"location":"programs/auction/#methods","text":"","title":"Methods"},{"location":"programs/auction/#transfer","text":"Transfer a XETA bid to the auction pool. Requirements: Bid higher than previous bid Outputs: Bid transfer from sender to pool , Return transfer from pool to previous highest bidder Inputs: Amount - Bid amount","title":"Transfer"},{"location":"programs/auction/#resolve","text":"Resolve a successfully concluded auction pool. Requirements: Pool closed or expired and bid >= xetaTarget , Pool active and bid = xetaLimit Outputs: NFT transfer from pool to highest bidder , XETA transfer from pool to pool creator Inputs: None","title":"Resolve"},{"location":"programs/auction/#cancel","text":"Cancel an unsuccessful auction pool. Requirements: Pool closed or expired and bid < xetaTarget Outputs: NFT transfer from pool to pool creator , XETA transfer from pool to highest bidder Inputs: None","title":"Cancel"},{"location":"programs/auction/#create","text":"Create an auction pool for a particular NFT. Requirements: Pool creator , Pool token ownership Outputs: Auction pool Inputs: Token - NFT address XetaTarget - Minimum bid for auction to be considered successful upon expiry XetaLimit - Maximum bid, equivalent to instant-buy bid TransfersLimit - Maximum limit of transfers Expires - Date and time of expiry","title":"Create"},{"location":"programs/auction/#deposit","text":"Deposit an NFT to the auction pool. Requirements: Pool creator , Pool token ownership Outputs: NFT transfer from sender to pool Inputs: Unlocks - Datetime when NFT claim can be unlocked and withdrawn","title":"Deposit"},{"location":"programs/auction/#close","text":"Closes an auction before expiry. Allows anyone to call cancel or resolve methods immediately. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Close"},{"location":"programs/launch/","text":"Launch Intro Launch pools allow creators to raise funds for a project by offering fungible tokens representing the project in exchange for XETA. Launch pools have a fixed rate of raising funds and a target (minimum) and limit (maximum) XETA amount. A successful launch pool (target amount reached before closure/expiry) automatically handles the liquidity deposit to the fungible token swap pool. Anyone who participated in the launch pool can then claim fungible tokens or recover their initial contribution if the launch didn\u2019t raise the target amount. Use Case: Raise funds for a project and automatically distribute raised funds to liquidity and/or creators. Functionality A fungible-token owner creates a launch pool for a fungible token and shares it with users who can participate by contributing XETA tokens. Pool creators can decide how many tokens they want to offer and how much they want to raise as a minimum and maximum amount. Once a launch expires or closes, participants can claim back either tokens (upon success) or their XETA contribution (upon failure). Since the pool automatically handles the liquidity deposit, successfully resolved launches are automatically tradeable at the token swap pool. Methods Transfer Transfer XETA to the launch pool to participate. Requirements: Active pool Outputs: XETA transfer from sender to pool , Transfer claim from pool to sender Inputs: Amount - XETA contribution amount Claim Claim tokens upon success or XETA contribution upon failure. Requirements: Concluded pool , Transfer claim Outputs: Token transfer from pool to sender on pool success , XETA transfer from pool to sender on pool failure Inputs: Claim - Claim hash Resolve Resolve launch pool after expiry or if creator manually closed pool. Requirements: Pool XetaBalance >= XetaTarget Outputs: Liquidity transfer from launch pool to swap pool , Funds transfer from launch pool to pool creator Inputs: Token - Pool token Create Create a launch pool for a fungible token. Requirements: Token balance Outputs: Launch pool Inputs: Token - Token to launch XetaTarget - Minimum XETA target XetaLimit - Maximum XETA limit Percentage - Percentage for liquidity vs. creator TransfersLimit - Maximum number of participants Expires - Datetime of expiry Deposit Deposit the fungible tokens and automatically determine the swap rate, based on 50% of the deposited amount allocated for swaps, 50% allocated for liquidity. Requirements: Pool creator Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Amount to be deposited Unlocks - Unlocks datetime for claim Withdraw Withdraw previously deposited tokens, or remainder for a closed launch. Requirements: Pool creator , Token balance in the pool Outputs: Token transfer from pool to sender Inputs: Claim - Claim hash Close Creators can close the launch pool manually before expiry. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Launch"},{"location":"programs/launch/#launch","text":"","title":"Launch"},{"location":"programs/launch/#intro","text":"Launch pools allow creators to raise funds for a project by offering fungible tokens representing the project in exchange for XETA. Launch pools have a fixed rate of raising funds and a target (minimum) and limit (maximum) XETA amount. A successful launch pool (target amount reached before closure/expiry) automatically handles the liquidity deposit to the fungible token swap pool. Anyone who participated in the launch pool can then claim fungible tokens or recover their initial contribution if the launch didn\u2019t raise the target amount. Use Case: Raise funds for a project and automatically distribute raised funds to liquidity and/or creators.","title":"Intro"},{"location":"programs/launch/#functionality","text":"A fungible-token owner creates a launch pool for a fungible token and shares it with users who can participate by contributing XETA tokens. Pool creators can decide how many tokens they want to offer and how much they want to raise as a minimum and maximum amount. Once a launch expires or closes, participants can claim back either tokens (upon success) or their XETA contribution (upon failure). Since the pool automatically handles the liquidity deposit, successfully resolved launches are automatically tradeable at the token swap pool.","title":"Functionality"},{"location":"programs/launch/#methods","text":"","title":"Methods"},{"location":"programs/launch/#transfer","text":"Transfer XETA to the launch pool to participate. Requirements: Active pool Outputs: XETA transfer from sender to pool , Transfer claim from pool to sender Inputs: Amount - XETA contribution amount","title":"Transfer"},{"location":"programs/launch/#claim","text":"Claim tokens upon success or XETA contribution upon failure. Requirements: Concluded pool , Transfer claim Outputs: Token transfer from pool to sender on pool success , XETA transfer from pool to sender on pool failure Inputs: Claim - Claim hash","title":"Claim"},{"location":"programs/launch/#resolve","text":"Resolve launch pool after expiry or if creator manually closed pool. Requirements: Pool XetaBalance >= XetaTarget Outputs: Liquidity transfer from launch pool to swap pool , Funds transfer from launch pool to pool creator Inputs: Token - Pool token","title":"Resolve"},{"location":"programs/launch/#create","text":"Create a launch pool for a fungible token. Requirements: Token balance Outputs: Launch pool Inputs: Token - Token to launch XetaTarget - Minimum XETA target XetaLimit - Maximum XETA limit Percentage - Percentage for liquidity vs. creator TransfersLimit - Maximum number of participants Expires - Datetime of expiry","title":"Create"},{"location":"programs/launch/#deposit","text":"Deposit the fungible tokens and automatically determine the swap rate, based on 50% of the deposited amount allocated for swaps, 50% allocated for liquidity. Requirements: Pool creator Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Amount to be deposited Unlocks - Unlocks datetime for claim","title":"Deposit"},{"location":"programs/launch/#withdraw","text":"Withdraw previously deposited tokens, or remainder for a closed launch. Requirements: Pool creator , Token balance in the pool Outputs: Token transfer from pool to sender Inputs: Claim - Claim hash","title":"Withdraw"},{"location":"programs/launch/#close","text":"Creators can close the launch pool manually before expiry. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Close"},{"location":"programs/lending/","text":"Lending Intro Lending pools allow users to borrow tokens against XETA collateral. Lending pools allow \u201cshort selling\u201d a token or resolving claims without owning the token. At the same time, it enables lenders to earn interest by making their tokens available for borrowers. Use Cases: Short-selling a borrowed token based on the assumption that tokens can be purchased back at a lower price (contributing to more efficient markets) Earning interest by lending out fungible tokens to borrowers Functionality A lending pool is created with a certain collateralization and interest rate. Lenders deposit tokens into the lending pool. Borrowers can then use it to borrow tokens while specifying the desired collateral. As long as the collateralization is kept above the minimum, users can keep tokens for as long as they wish and pay the respective interest rate upon settlement. If, however, the collateralization rate falls below the minimum, any user can liquidate the borrower's claim, which applies penalties equivalent to a one-year interest rate to the borrower's collateral. All collected funds, via interest rate paid by the borrower, including liquidations, are collected and proportionally divided between lenders based on lending duration and lending amount. Lending pools make it possible for lenders to earn a steady and predictable interest rate. Methods Transfer Lend tokens from the lending pool at certain collateralization. Requirements: Collateralization >= Min. collateralization Outputs: XETA transfer from sender to pool , Token transfer from pool to sender Inputs: Token - Pool token (token to borrow) Collateralization - Desired collateralization rate Amount - XETA amount to be transferred as collateral Settle Return previously lent tokens while paying an interest rate based on the rate specified by the pool and the lending duration. Requirements: None Outputs: Token transfer from sender to pool , XETA transfer from pool to sender Inputs: Claim - Claim hash Liquidate Liquidate someone\u2019s claim that has dropped below 75% of the minimum collateralization required by the pool. Requirements: Claim collateralization < 0.75 * min. collateralization Outputs: XETA transfer from pool to borrower for remaining collateral , XETA transfer from pool to liquidator for finders reward Inputs: Claim - Claim hash Token - Pool token Deposit Deposit tokens as specified by the pool to earn a specific interest rate. Requirements: None Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - The deposited amount Unlocks - A datetime when the deposit claim can be redeemed Withdraw Withdraw tokens that have been deposited previously to the lending pool. Requirements: Active deposit claim Outputs: Token transfer from pool to sender , XETA transfer from pool to sender for interest earned Inputs: Claim - Deposit claim hash Token - Pool token Percentage - Percentage to withdraw Create Create a lending pool for a fungible token. Requirements: None Outputs: Lending pool Inputs: Token - Token to lend/borrow Percentage - Collateralization rate Rate - Annual interest rate \\pagebreak","title":"Lending"},{"location":"programs/lending/#lending","text":"","title":"Lending"},{"location":"programs/lending/#intro","text":"Lending pools allow users to borrow tokens against XETA collateral. Lending pools allow \u201cshort selling\u201d a token or resolving claims without owning the token. At the same time, it enables lenders to earn interest by making their tokens available for borrowers. Use Cases: Short-selling a borrowed token based on the assumption that tokens can be purchased back at a lower price (contributing to more efficient markets) Earning interest by lending out fungible tokens to borrowers","title":"Intro"},{"location":"programs/lending/#functionality","text":"A lending pool is created with a certain collateralization and interest rate. Lenders deposit tokens into the lending pool. Borrowers can then use it to borrow tokens while specifying the desired collateral. As long as the collateralization is kept above the minimum, users can keep tokens for as long as they wish and pay the respective interest rate upon settlement. If, however, the collateralization rate falls below the minimum, any user can liquidate the borrower's claim, which applies penalties equivalent to a one-year interest rate to the borrower's collateral. All collected funds, via interest rate paid by the borrower, including liquidations, are collected and proportionally divided between lenders based on lending duration and lending amount. Lending pools make it possible for lenders to earn a steady and predictable interest rate.","title":"Functionality"},{"location":"programs/lending/#methods","text":"","title":"Methods"},{"location":"programs/lending/#transfer","text":"Lend tokens from the lending pool at certain collateralization. Requirements: Collateralization >= Min. collateralization Outputs: XETA transfer from sender to pool , Token transfer from pool to sender Inputs: Token - Pool token (token to borrow) Collateralization - Desired collateralization rate Amount - XETA amount to be transferred as collateral","title":"Transfer"},{"location":"programs/lending/#settle","text":"Return previously lent tokens while paying an interest rate based on the rate specified by the pool and the lending duration. Requirements: None Outputs: Token transfer from sender to pool , XETA transfer from pool to sender Inputs: Claim - Claim hash","title":"Settle"},{"location":"programs/lending/#liquidate","text":"Liquidate someone\u2019s claim that has dropped below 75% of the minimum collateralization required by the pool. Requirements: Claim collateralization < 0.75 * min. collateralization Outputs: XETA transfer from pool to borrower for remaining collateral , XETA transfer from pool to liquidator for finders reward Inputs: Claim - Claim hash Token - Pool token","title":"Liquidate"},{"location":"programs/lending/#deposit","text":"Deposit tokens as specified by the pool to earn a specific interest rate. Requirements: None Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - The deposited amount Unlocks - A datetime when the deposit claim can be redeemed","title":"Deposit"},{"location":"programs/lending/#withdraw","text":"Withdraw tokens that have been deposited previously to the lending pool. Requirements: Active deposit claim Outputs: Token transfer from pool to sender , XETA transfer from pool to sender for interest earned Inputs: Claim - Deposit claim hash Token - Pool token Percentage - Percentage to withdraw","title":"Withdraw"},{"location":"programs/lending/#create","text":"Create a lending pool for a fungible token. Requirements: None Outputs: Lending pool Inputs: Token - Token to lend/borrow Percentage - Collateralization rate Rate - Annual interest rate \\pagebreak","title":"Create"},{"location":"programs/lock/","text":"Lock Intro Lock pools make it possible for anyone with a fungible-token balance to lock tokens for a specific time. Locks can be set to unlock after a particular date or be valid only before a date through an expiration mechanism. Furthermore, lock pools allow the transfer of lock claim ownership to other addresses. Use Cases: Locking fungible-tokens for someone (e.g. allocated for another entity as a form of vesting) Locking fungible-tokens until a specific datetime Locking fungible-tokens claimable after a particular date, and before an expiry date Functionality A lock pool is created for a particular token. Users can then use this pool to lock their tokens in exchange for a lock claim. This claim can then be redeemed after the locking period expires. Lock claims can be assigned to another address, allowing project creators to distribute tokens to others in a locked state. Methods Transfer Create a new lock-claim for the token as specified by the pool. Requirements: Token balance Outputs: Token transfer from sender to pool , Lock claim from pool to sender Inputs: Amount - Fungible-token amount to be locked Address - Address for which to lock the tokens Unlocks - Datetime from which the claim will be claimable Expires - Datetime at which the claim will expire and become non-claimable Claim Allows participants with a valid lock-claim to unlock tokens from the lock-pool. Requirements: Active lock claim Outputs: Token transfer from pool to sender Inputs: Claim - Lock claim hash \\pagebreak","title":"Lock"},{"location":"programs/lock/#lock","text":"","title":"Lock"},{"location":"programs/lock/#intro","text":"Lock pools make it possible for anyone with a fungible-token balance to lock tokens for a specific time. Locks can be set to unlock after a particular date or be valid only before a date through an expiration mechanism. Furthermore, lock pools allow the transfer of lock claim ownership to other addresses. Use Cases: Locking fungible-tokens for someone (e.g. allocated for another entity as a form of vesting) Locking fungible-tokens until a specific datetime Locking fungible-tokens claimable after a particular date, and before an expiry date","title":"Intro"},{"location":"programs/lock/#functionality","text":"A lock pool is created for a particular token. Users can then use this pool to lock their tokens in exchange for a lock claim. This claim can then be redeemed after the locking period expires. Lock claims can be assigned to another address, allowing project creators to distribute tokens to others in a locked state.","title":"Functionality"},{"location":"programs/lock/#methods","text":"","title":"Methods"},{"location":"programs/lock/#transfer","text":"Create a new lock-claim for the token as specified by the pool. Requirements: Token balance Outputs: Token transfer from sender to pool , Lock claim from pool to sender Inputs: Amount - Fungible-token amount to be locked Address - Address for which to lock the tokens Unlocks - Datetime from which the claim will be claimable Expires - Datetime at which the claim will expire and become non-claimable","title":"Transfer"},{"location":"programs/lock/#claim","text":"Allows participants with a valid lock-claim to unlock tokens from the lock-pool. Requirements: Active lock claim Outputs: Token transfer from pool to sender Inputs: Claim - Lock claim hash \\pagebreak","title":"Claim"},{"location":"programs/loot/","text":"Loot Intro Loot pools enable token-creators to promote their NFTs in a randomized fashion. Loot pools are equivalent to NFT drops. Users can participate by paying a certain fungible-token amount and receiving a random NFT with a certain probability. Use Case: Distributing or launching an NFT collection through randomized token distribution process Functionality The creator or owner of NFTs creates a loot pool and sets parameters such as the participation amount and win-probability. The creator deposits NFTs to the pool to be distributed. Participants can then enter by transferring the entry amount to receive a random NFT with a specific probability from the pool. Methods Transfer Participate in the loot pool by transferring the required participation amount. Requirements: Positive NFT balance by pool Outputs: NFT transfer to sender based on win-probability Inputs: None Create Create a new loot pool. Requirements: None Outputs: Loot pool Inputs: Token - A fungible token to be used as participation token Percentage - Probability to win, between 0 and 1 MinAmount - Participation amount Expires - Datetime when the loot pool expires Deposit Deposit an NFT as loot to the loot pool. Requirements: Pool creator , NFT ownership Outputs: NFT transfer from sender to pool , Deposit claim from pool to sender Inputs: Token - NFT token to deposit to the loot pool Unlocks - Time until which the token will remain locked in the pool Withdraw Withdraw a previously deposited NFT, which has not been distributed yet. Requirements: Pool creator , Active deposit claim Outputs: NFT transfer from pool to sender Inputs: Claim - Deposit claim hash Clear Clear all fungible-token proceeds held by the pool collected as entry amounts by participants by transferring them to the creator. Requirements: Pool creator , Token balance by pool Outputs: Token transfer from pool to pool creator Inputs: None \\pagebreak","title":"Loot"},{"location":"programs/loot/#loot","text":"","title":"Loot"},{"location":"programs/loot/#intro","text":"Loot pools enable token-creators to promote their NFTs in a randomized fashion. Loot pools are equivalent to NFT drops. Users can participate by paying a certain fungible-token amount and receiving a random NFT with a certain probability. Use Case: Distributing or launching an NFT collection through randomized token distribution process","title":"Intro"},{"location":"programs/loot/#functionality","text":"The creator or owner of NFTs creates a loot pool and sets parameters such as the participation amount and win-probability. The creator deposits NFTs to the pool to be distributed. Participants can then enter by transferring the entry amount to receive a random NFT with a specific probability from the pool.","title":"Functionality"},{"location":"programs/loot/#methods","text":"","title":"Methods"},{"location":"programs/loot/#transfer","text":"Participate in the loot pool by transferring the required participation amount. Requirements: Positive NFT balance by pool Outputs: NFT transfer to sender based on win-probability Inputs: None","title":"Transfer"},{"location":"programs/loot/#create","text":"Create a new loot pool. Requirements: None Outputs: Loot pool Inputs: Token - A fungible token to be used as participation token Percentage - Probability to win, between 0 and 1 MinAmount - Participation amount Expires - Datetime when the loot pool expires","title":"Create"},{"location":"programs/loot/#deposit","text":"Deposit an NFT as loot to the loot pool. Requirements: Pool creator , NFT ownership Outputs: NFT transfer from sender to pool , Deposit claim from pool to sender Inputs: Token - NFT token to deposit to the loot pool Unlocks - Time until which the token will remain locked in the pool","title":"Deposit"},{"location":"programs/loot/#withdraw","text":"Withdraw a previously deposited NFT, which has not been distributed yet. Requirements: Pool creator , Active deposit claim Outputs: NFT transfer from pool to sender Inputs: Claim - Deposit claim hash","title":"Withdraw"},{"location":"programs/loot/#clear","text":"Clear all fungible-token proceeds held by the pool collected as entry amounts by participants by transferring them to the creator. Requirements: Pool creator , Token balance by pool Outputs: Token transfer from pool to pool creator Inputs: None \\pagebreak","title":"Clear"},{"location":"programs/lottery/","text":"Lottery Intro Lottery pools allow the distribution of fungible or non-fungible tokens in a randomized way. Lotteries can be based on specific criteria, such as a minimum token amount that someone must hold to participate or require a minimum amount to enter. After a lottery expires, it can be resolved to automatically distribute the NFT or make the fungible tokens claimable for winning participants. Use Cases: Distributing an NFT through a randomized mechanism and a single winner Distributing fungible-tokens through a randomized mechanism Functionality A lottery pool can promote a fungible or single non-fungible token to participants, who can enter to win with a probability dependent on the number of entries. After creating the lottery pool, the creator must deposit the fungible tokens or a single NFT. Once the deposit is complete, any user can participate, either for free or the minimum amount required by the pool. Furthermore, pools can set a minimum amount of XETA that a user needs to hold to be eligible to participate. Requiring a minimum amount of XETA to participate improves incentives and prevents dishonest entries (especially if the lottery pool is sponsored). After the lottery pool expires, the resolution call automatically transfers the NFT to a single winner chosen from all participants. If the lottery is promoting a fungible token, winners (based on the pools\u2019 probability) can claim their fungible-token rewards using their claimable ticket. Methods Transfer Transfer the entry amount to participate in the lottery. Requirements: Token balance , XETA balance Outputs: XETA transfer from sender to pool , Transfer claim from pool to sender Inputs: None Claim Claim a lottery ticket, and receive the pool token with a certain probability. Requirements: Active transfer claim Outputs: NFT or token with a probability as specified by the pool Inputs: Claim - Claim hash Resolve Resolve a lottery pool and determine the winner of an NFT lottery. Requirements: NFT lottery Outputs: NFT transfer from pool to random participant Inputs: None Create Create a lottery pool for fungible tokens or a single non-fungible token. Requirements: None Outputs: Lottery pool Inputs: Token - The token which is to be promoted MinAmount - Participation amount TokenTarget - Amount of pool tokens that someone must hold to participate XetaTarget - Amount of XETA, that someone must hold to participate TransfersLimit - Maximum amount of participants ClaimsLimit - Maximum number of winners Expires - Datetime when lottery naturally expires Deposit Allows the creator to deposit the pool token. Requirements: Pool creator Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Amount in case of a fungible-token lottery Unlocks - Datetime when the claim unlocks Withdraw Allows the creator to withdraw a previously deposited pool token. Requirements: Pool creator , Active deposit claim Outputs: Token transfer from pool to sender Inputs: Claim - Deposit claim hash Close The creator can close the lottery before expiration. If there are participants, the creator can only withdraw the unclaimable share. Requirements: Pool creator Outputs: None Inputs: None Clear Allows the creator to clear XETA earnings collected by the lottery pool if the participation amount is positive. Requirements: Pool creator , XETA balance by pool Outputs: XETA transfer from pool to pool creator Inputs: None \\pagebreak","title":"Lottery"},{"location":"programs/lottery/#lottery","text":"","title":"Lottery"},{"location":"programs/lottery/#intro","text":"Lottery pools allow the distribution of fungible or non-fungible tokens in a randomized way. Lotteries can be based on specific criteria, such as a minimum token amount that someone must hold to participate or require a minimum amount to enter. After a lottery expires, it can be resolved to automatically distribute the NFT or make the fungible tokens claimable for winning participants. Use Cases: Distributing an NFT through a randomized mechanism and a single winner Distributing fungible-tokens through a randomized mechanism","title":"Intro"},{"location":"programs/lottery/#functionality","text":"A lottery pool can promote a fungible or single non-fungible token to participants, who can enter to win with a probability dependent on the number of entries. After creating the lottery pool, the creator must deposit the fungible tokens or a single NFT. Once the deposit is complete, any user can participate, either for free or the minimum amount required by the pool. Furthermore, pools can set a minimum amount of XETA that a user needs to hold to be eligible to participate. Requiring a minimum amount of XETA to participate improves incentives and prevents dishonest entries (especially if the lottery pool is sponsored). After the lottery pool expires, the resolution call automatically transfers the NFT to a single winner chosen from all participants. If the lottery is promoting a fungible token, winners (based on the pools\u2019 probability) can claim their fungible-token rewards using their claimable ticket.","title":"Functionality"},{"location":"programs/lottery/#methods","text":"","title":"Methods"},{"location":"programs/lottery/#transfer","text":"Transfer the entry amount to participate in the lottery. Requirements: Token balance , XETA balance Outputs: XETA transfer from sender to pool , Transfer claim from pool to sender Inputs: None","title":"Transfer"},{"location":"programs/lottery/#claim","text":"Claim a lottery ticket, and receive the pool token with a certain probability. Requirements: Active transfer claim Outputs: NFT or token with a probability as specified by the pool Inputs: Claim - Claim hash","title":"Claim"},{"location":"programs/lottery/#resolve","text":"Resolve a lottery pool and determine the winner of an NFT lottery. Requirements: NFT lottery Outputs: NFT transfer from pool to random participant Inputs: None","title":"Resolve"},{"location":"programs/lottery/#create","text":"Create a lottery pool for fungible tokens or a single non-fungible token. Requirements: None Outputs: Lottery pool Inputs: Token - The token which is to be promoted MinAmount - Participation amount TokenTarget - Amount of pool tokens that someone must hold to participate XetaTarget - Amount of XETA, that someone must hold to participate TransfersLimit - Maximum amount of participants ClaimsLimit - Maximum number of winners Expires - Datetime when lottery naturally expires","title":"Create"},{"location":"programs/lottery/#deposit","text":"Allows the creator to deposit the pool token. Requirements: Pool creator Outputs: Token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Amount in case of a fungible-token lottery Unlocks - Datetime when the claim unlocks","title":"Deposit"},{"location":"programs/lottery/#withdraw","text":"Allows the creator to withdraw a previously deposited pool token. Requirements: Pool creator , Active deposit claim Outputs: Token transfer from pool to sender Inputs: Claim - Deposit claim hash","title":"Withdraw"},{"location":"programs/lottery/#close","text":"The creator can close the lottery before expiration. If there are participants, the creator can only withdraw the unclaimable share. Requirements: Pool creator Outputs: None Inputs: None","title":"Close"},{"location":"programs/lottery/#clear","text":"Allows the creator to clear XETA earnings collected by the lottery pool if the participation amount is positive. Requirements: Pool creator , XETA balance by pool Outputs: XETA transfer from pool to pool creator Inputs: None \\pagebreak","title":"Clear"},{"location":"programs/royalty/","text":"Royalty Intro Royalty pools allow NFT creators to allocate a particular token for royalty payouts of NFT holders. Anyone who owns an NFT specified by a royalty pool can claim royalties based on the holding duration. Use Cases: Reward NFT holders based on the length of holding a certain NFT Pay a passive income/royalties for anything in the physical or virtual reality, represented by an NFT Functionality A creator creates a royalty pool and specifies candidates and a linear pay-out rate of rewards. After depositing rewards, any owner of NFTs created by the creator (and as determined by the royalty pool) can then periodically claim royalties from the pool. Royalties accumulate every day until a claim is made (claims reset the daily counter). Methods Claim Claim royalties for an NFT created by the royalty-pool creator, depending on the length of holding the NFT. Requirements: Claim answer in pool candidates, or no candidates Outputs: Royalty transfer from pool to sender Inputs: Token - Token address Create Create a royalty pool while specifying the eligible NFT candidates and a daily royalty rate. Requirements: None Outputs: Royalty pool Inputs: Token - A fungible token that is used as reward payout Candidates - A list of NFT candidates, or empty if all NFTs by the creator should be eligible Rate - Amount of pool-tokens that is paid for every day of holding the NFT Expires - Datetime when the royalty pool is no longer valid Deposit Deposit a certain amount of pool-tokens available as reward payouts for NFT holders. Requirements: Pool creator Outputs: Reward token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Reward amount to be deposited Unlocks - Datetime when the deposit claim can be withdrawn Withdraw Withdraw previously deposited reward tokens (partially if rewards have been claimed already). Requirements: Pool creator , Active deposit claim , Token balance by pool Outputs: Token transfer from pool to sender Inputs: Claim - Deposit claim hash Close The creator can close a royalty pool at any time, making it impossible to claim additional royalties. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Royalty"},{"location":"programs/royalty/#royalty","text":"","title":"Royalty"},{"location":"programs/royalty/#intro","text":"Royalty pools allow NFT creators to allocate a particular token for royalty payouts of NFT holders. Anyone who owns an NFT specified by a royalty pool can claim royalties based on the holding duration. Use Cases: Reward NFT holders based on the length of holding a certain NFT Pay a passive income/royalties for anything in the physical or virtual reality, represented by an NFT","title":"Intro"},{"location":"programs/royalty/#functionality","text":"A creator creates a royalty pool and specifies candidates and a linear pay-out rate of rewards. After depositing rewards, any owner of NFTs created by the creator (and as determined by the royalty pool) can then periodically claim royalties from the pool. Royalties accumulate every day until a claim is made (claims reset the daily counter).","title":"Functionality"},{"location":"programs/royalty/#methods","text":"","title":"Methods"},{"location":"programs/royalty/#claim","text":"Claim royalties for an NFT created by the royalty-pool creator, depending on the length of holding the NFT. Requirements: Claim answer in pool candidates, or no candidates Outputs: Royalty transfer from pool to sender Inputs: Token - Token address","title":"Claim"},{"location":"programs/royalty/#create","text":"Create a royalty pool while specifying the eligible NFT candidates and a daily royalty rate. Requirements: None Outputs: Royalty pool Inputs: Token - A fungible token that is used as reward payout Candidates - A list of NFT candidates, or empty if all NFTs by the creator should be eligible Rate - Amount of pool-tokens that is paid for every day of holding the NFT Expires - Datetime when the royalty pool is no longer valid","title":"Create"},{"location":"programs/royalty/#deposit","text":"Deposit a certain amount of pool-tokens available as reward payouts for NFT holders. Requirements: Pool creator Outputs: Reward token transfer from sender to pool , Deposit claim from pool to sender Inputs: Amount - Reward amount to be deposited Unlocks - Datetime when the deposit claim can be withdrawn","title":"Deposit"},{"location":"programs/royalty/#withdraw","text":"Withdraw previously deposited reward tokens (partially if rewards have been claimed already). Requirements: Pool creator , Active deposit claim , Token balance by pool Outputs: Token transfer from pool to sender Inputs: Claim - Deposit claim hash","title":"Withdraw"},{"location":"programs/royalty/#close","text":"The creator can close a royalty pool at any time, making it impossible to claim additional royalties. Requirements: Pool creator Outputs: None Inputs: None \\pagebreak","title":"Close"},{"location":"programs/staking/","text":"Staking Intro Staking pools allow creators to reward holders for locking (staking) their tokens for a definite period. After the period passes, the participant can unlock their staked tokens and receive an additional reward from the deposited rewards, based on the specified yearly interest rate and yearly interest bonus. Use Case: Rewarding holders of a fungible token with a certain APY and bonus rate for committing their holding by locking tokens Functionality A creator creates a staking pool with a specific yearly APY rate and an optional bonus percentage. Optionally, a minimum/maximum amount and locking time may be set. After the pool is created, the creator deposits tokens as reward payouts. Any holder of the pool token can lock and commit their tokens for a reward payout based on staking time and APY, and bonus rate. Once the staking period passes, the participant can unlock their tokens and receive their initial stake, including the interest rate as defined by the pool. Methods Transfer Stake tokens by locking them for a specific time. Requirements: Min/max amount valid , Min/max time valid Outputs: Token transfer from sender to pool , Staking claim from pool to sender Inputs: Amount - Staking amount Unlocks - Datetime until which the amount will be locked Claim Claim back the initial stake, including rewards accumulated during the staking period. Requirements: Active staking claim Outputs: Token transfer from pool to sender (with rewards) Inputs: Claim - Claim hash Withdraw Withdraws reward tokens as creator or deposited tokens as a participant (but without rewards). Requirements: Active staking claim Outputs: Token transfer from pool to sender (without rewards) Inputs: Claim - Deposit claim hash Percentage - Percentage to withdraw (defaults to 1 equivalent to 100%) Create Create a staking pool with a specific APY rate and bonus percentage. Requirements: None Outputs: Staking pool Inputs: Token - Pool token to be staked and paid as rewards Rate - The yearly APY rate Percentage - A bonus percentage, paid additional to the annual APY rate for one year of holding MinAmount - Minimum staking amount MaxAmount - Maximum staking amount MinTime - Minimum staking time in seconds MaxTime - Maximum staking time in seconds TransfersLimit - Maximum number of transfers to the staking pool Expires - Datetime when the staking pool expires and is not accepting new participants Deposit Deposit reward tokens to the staking pool. Requirements: Pool creator Outputs: Token transfer from sender to pool Inputs: Amount - Amount to be deposited as rewards Unlocks - Lock time of the reward token claim \\pagebreak","title":"Staking"},{"location":"programs/staking/#staking","text":"","title":"Staking"},{"location":"programs/staking/#intro","text":"Staking pools allow creators to reward holders for locking (staking) their tokens for a definite period. After the period passes, the participant can unlock their staked tokens and receive an additional reward from the deposited rewards, based on the specified yearly interest rate and yearly interest bonus. Use Case: Rewarding holders of a fungible token with a certain APY and bonus rate for committing their holding by locking tokens","title":"Intro"},{"location":"programs/staking/#functionality","text":"A creator creates a staking pool with a specific yearly APY rate and an optional bonus percentage. Optionally, a minimum/maximum amount and locking time may be set. After the pool is created, the creator deposits tokens as reward payouts. Any holder of the pool token can lock and commit their tokens for a reward payout based on staking time and APY, and bonus rate. Once the staking period passes, the participant can unlock their tokens and receive their initial stake, including the interest rate as defined by the pool.","title":"Functionality"},{"location":"programs/staking/#methods","text":"","title":"Methods"},{"location":"programs/staking/#transfer","text":"Stake tokens by locking them for a specific time. Requirements: Min/max amount valid , Min/max time valid Outputs: Token transfer from sender to pool , Staking claim from pool to sender Inputs: Amount - Staking amount Unlocks - Datetime until which the amount will be locked","title":"Transfer"},{"location":"programs/staking/#claim","text":"Claim back the initial stake, including rewards accumulated during the staking period. Requirements: Active staking claim Outputs: Token transfer from pool to sender (with rewards) Inputs: Claim - Claim hash","title":"Claim"},{"location":"programs/staking/#withdraw","text":"Withdraws reward tokens as creator or deposited tokens as a participant (but without rewards). Requirements: Active staking claim Outputs: Token transfer from pool to sender (without rewards) Inputs: Claim - Deposit claim hash Percentage - Percentage to withdraw (defaults to 1 equivalent to 100%)","title":"Withdraw"},{"location":"programs/staking/#create","text":"Create a staking pool with a specific APY rate and bonus percentage. Requirements: None Outputs: Staking pool Inputs: Token - Pool token to be staked and paid as rewards Rate - The yearly APY rate Percentage - A bonus percentage, paid additional to the annual APY rate for one year of holding MinAmount - Minimum staking amount MaxAmount - Maximum staking amount MinTime - Minimum staking time in seconds MaxTime - Maximum staking time in seconds TransfersLimit - Maximum number of transfers to the staking pool Expires - Datetime when the staking pool expires and is not accepting new participants","title":"Create"},{"location":"programs/staking/#deposit","text":"Deposit reward tokens to the staking pool. Requirements: Pool creator Outputs: Token transfer from sender to pool Inputs: Amount - Amount to be deposited as rewards Unlocks - Lock time of the reward token claim \\pagebreak","title":"Deposit"},{"location":"programs/swap/","text":"Swap Intro Swap pools are automatically created for every fungible token that is minted. These allow participants to swap tokens against XETA and vice versa in a decentralized way. The price is based on the liquidity that token creators and participants can contribute, and the trades that affect the liquidity. Use Case: Decentralized exchange mechanism for fungible tokens Functionality A swap pool is automatically created with the creation of every fungible token. Creators can add liquidity via a launch pool, or directly by depositing the pool tokens and XETA. The amount of deposited liquidity determines the price, which is determined by dividing the number of tokens available as liquidity by the amount of XETA available as liquidity. Participants can swap XETA for tokens or tokens for XETA. Transfers in and out are entirely handled by the program in an automated way, charging 0.25% commission on every trade and automatically adding 1% of the trade value to the pools\u2019 liquidity. Methods Transfer Swap tokens into XETA or XETA into tokens at the current exchange rate. Requirements: Pool liquidity Outputs: Transfer from sender to pool , Transfer from pool to sender Inputs: Token - XETA or the pool-token, to use as input token Amount - Number of tokens to swap Deposit Deposit XETA and tokens to liquidity at a specific rate. Requirements: XETA balance , Token balance Outputs: XETA transfer from sender to pool , Token transfer from sender to pool , Liquidity deposit claim from pool to sender Inputs: TokenAmount - Amount of tokens to deposit XetaAmount - Amount of XETA to deposit Unlocks - Datetime when the deposit claim shall unlock Withdraw Allows withdrawing previously deposited liquidity tokens adjusted for the new liquidity rate. Requirements: Active liquidity deposit claim Outputs: XETA transfer from pool to sender , Token transfer from pool to sender Inputs: Claim - Deposit claim hash Percentage - Percentage between 0-1 to withdraw \\pagebreak","title":"Swap"},{"location":"programs/swap/#swap","text":"","title":"Swap"},{"location":"programs/swap/#intro","text":"Swap pools are automatically created for every fungible token that is minted. These allow participants to swap tokens against XETA and vice versa in a decentralized way. The price is based on the liquidity that token creators and participants can contribute, and the trades that affect the liquidity. Use Case: Decentralized exchange mechanism for fungible tokens","title":"Intro"},{"location":"programs/swap/#functionality","text":"A swap pool is automatically created with the creation of every fungible token. Creators can add liquidity via a launch pool, or directly by depositing the pool tokens and XETA. The amount of deposited liquidity determines the price, which is determined by dividing the number of tokens available as liquidity by the amount of XETA available as liquidity. Participants can swap XETA for tokens or tokens for XETA. Transfers in and out are entirely handled by the program in an automated way, charging 0.25% commission on every trade and automatically adding 1% of the trade value to the pools\u2019 liquidity.","title":"Functionality"},{"location":"programs/swap/#methods","text":"","title":"Methods"},{"location":"programs/swap/#transfer","text":"Swap tokens into XETA or XETA into tokens at the current exchange rate. Requirements: Pool liquidity Outputs: Transfer from sender to pool , Transfer from pool to sender Inputs: Token - XETA or the pool-token, to use as input token Amount - Number of tokens to swap","title":"Transfer"},{"location":"programs/swap/#deposit","text":"Deposit XETA and tokens to liquidity at a specific rate. Requirements: XETA balance , Token balance Outputs: XETA transfer from sender to pool , Token transfer from sender to pool , Liquidity deposit claim from pool to sender Inputs: TokenAmount - Amount of tokens to deposit XetaAmount - Amount of XETA to deposit Unlocks - Datetime when the deposit claim shall unlock","title":"Deposit"},{"location":"programs/swap/#withdraw","text":"Allows withdrawing previously deposited liquidity tokens adjusted for the new liquidity rate. Requirements: Active liquidity deposit claim Outputs: XETA transfer from pool to sender , Token transfer from pool to sender Inputs: Claim - Deposit claim hash Percentage - Percentage between 0-1 to withdraw \\pagebreak","title":"Withdraw"},{"location":"programs/vote/","text":"Vote Intro The voting pool allows participants to vote on a numeric outcome (such as bets, estimations, budgets, prediction markets) or on an outcome based on provided answers. Voting pools can require a contribution amount, which serves as a weight for the vote. Vote pools can be resolved using various mechanisms: transferring all collected tokens to the creator, the highest candidate, or the voters (by the highest voted answer or through oracle result). Use Cases: Voting on a numeric outcome (bets, estimations, budgets, prediction markets) Voting on an answer outcome (guesses, candidates, tokens, proposals) Voting by collecting funds and rewarding the vote pool creator Voting by collecting funds and rewarding the highest voted candidate Voting by collecting funds and rewarding voters of the highest voted answer Voting by collecting funds and rewarding voters of the correct answer, as determined by an oracle Functionality A creator creates a voting pool and specifies the participation token, resolution mechanism, and optional candidates. Optionally, a minimum/maximum participation amount can be specified. Voters can then vote by providing a numerical answer (if the voting pool is a numerical vote) or by providing one of the specified answer candidates. Every vote can be weighted by the XETA participation amount. After the vote expires, it can be resolved based on the specified resolution mechanism. The mechanism rewards the creator, candidates or voters of the highest voted answer or the correct answer as determined by an oracle. If the mechanism rewards voters of the highest or correct answer, they can claim their rewards proportional to their weighted vote. Methods Transfer Participate in the voting pool by providing a numerical answer or a candidate from the available choices. Requirements: None Outputs: Transfer claim from pool to sender Inputs: Amount - XETA amount to add weight to the vote Answer - Choice from available candidates Number - Number if the vote is numerical Claim Allows claiming rewards, proportional to the weighted vote divided by the total weight of the winning vote. Requirements: Claim with valid answer Outputs: Reward transfer from pool to sender Inputs: Claim - Claim hash Resolve Resolves vote using the specified vote-pool mechanism. Pays collected XETA weight amounts to either creator, top candidate or enables voters of the highest answer to claim their rewards. Requirements: Vote mechanism != oracle Outputs: Rewards transfer from pool to creator/candidate Inputs: None Create Creates a voting pool, with a numerical or candidate type and a specific resolution mechanism. Requirements: None Outputs: Vote pool Inputs: Mechanism - Resolution mechanism, creator, candidate, voters, oracle Candidates - List of candidates to vote on, numerical vote if empty MinAmount - Minimum amount to participate in vote MaxAmount - Maximum amount to participate in vote TransfersLimit - Maximum number of votes ClaimsLimit - Maximum number of winning votes for top candidate XetaLimit - Maximum collected XETA as vote-weights Expires - Datetime when the vote expires Oracle The creator can set the correct answer so voters who claimed that answer can claim their rewards. Requirements: Pool creator , Candidate pool , Pool mechanism = oracle Outputs: None Inputs: Answer - Correct answer \\pagebreak","title":"Vote"},{"location":"programs/vote/#vote","text":"","title":"Vote"},{"location":"programs/vote/#intro","text":"The voting pool allows participants to vote on a numeric outcome (such as bets, estimations, budgets, prediction markets) or on an outcome based on provided answers. Voting pools can require a contribution amount, which serves as a weight for the vote. Vote pools can be resolved using various mechanisms: transferring all collected tokens to the creator, the highest candidate, or the voters (by the highest voted answer or through oracle result). Use Cases: Voting on a numeric outcome (bets, estimations, budgets, prediction markets) Voting on an answer outcome (guesses, candidates, tokens, proposals) Voting by collecting funds and rewarding the vote pool creator Voting by collecting funds and rewarding the highest voted candidate Voting by collecting funds and rewarding voters of the highest voted answer Voting by collecting funds and rewarding voters of the correct answer, as determined by an oracle","title":"Intro"},{"location":"programs/vote/#functionality","text":"A creator creates a voting pool and specifies the participation token, resolution mechanism, and optional candidates. Optionally, a minimum/maximum participation amount can be specified. Voters can then vote by providing a numerical answer (if the voting pool is a numerical vote) or by providing one of the specified answer candidates. Every vote can be weighted by the XETA participation amount. After the vote expires, it can be resolved based on the specified resolution mechanism. The mechanism rewards the creator, candidates or voters of the highest voted answer or the correct answer as determined by an oracle. If the mechanism rewards voters of the highest or correct answer, they can claim their rewards proportional to their weighted vote.","title":"Functionality"},{"location":"programs/vote/#methods","text":"","title":"Methods"},{"location":"programs/vote/#transfer","text":"Participate in the voting pool by providing a numerical answer or a candidate from the available choices. Requirements: None Outputs: Transfer claim from pool to sender Inputs: Amount - XETA amount to add weight to the vote Answer - Choice from available candidates Number - Number if the vote is numerical","title":"Transfer"},{"location":"programs/vote/#claim","text":"Allows claiming rewards, proportional to the weighted vote divided by the total weight of the winning vote. Requirements: Claim with valid answer Outputs: Reward transfer from pool to sender Inputs: Claim - Claim hash","title":"Claim"},{"location":"programs/vote/#resolve","text":"Resolves vote using the specified vote-pool mechanism. Pays collected XETA weight amounts to either creator, top candidate or enables voters of the highest answer to claim their rewards. Requirements: Vote mechanism != oracle Outputs: Rewards transfer from pool to creator/candidate Inputs: None","title":"Resolve"},{"location":"programs/vote/#create","text":"Creates a voting pool, with a numerical or candidate type and a specific resolution mechanism. Requirements: None Outputs: Vote pool Inputs: Mechanism - Resolution mechanism, creator, candidate, voters, oracle Candidates - List of candidates to vote on, numerical vote if empty MinAmount - Minimum amount to participate in vote MaxAmount - Maximum amount to participate in vote TransfersLimit - Maximum number of votes ClaimsLimit - Maximum number of winning votes for top candidate XetaLimit - Maximum collected XETA as vote-weights Expires - Datetime when the vote expires","title":"Create"},{"location":"programs/vote/#oracle","text":"The creator can set the correct answer so voters who claimed that answer can claim their rewards. Requirements: Pool creator , Candidate pool , Pool mechanism = oracle Outputs: None Inputs: Answer - Correct answer \\pagebreak","title":"Oracle"}]}